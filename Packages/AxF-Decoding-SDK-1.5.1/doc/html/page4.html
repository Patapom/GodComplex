<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AxF Decoding SDK: Performance Guidelines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="AxF-SDK-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AxF Decoding SDK
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">Decoding AxF representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">AxF Decoding SDK</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Performance Guidelines </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#guidelines_sec02">Optimizing Performance and Memory Consumption</a><ul><li class="level2"><a href="#guidelines_sec02_ssec01">Reducing numerical precision</a><ul><li class="level3"><a href="#guidelines_sec02_ssec01_sssec01">Half-precision floating point format</a></li>
<li class="level3"><a href="#guidelines_sec02_ssec01_sssec02">Fixed point numbers</a></li>
<li class="level3"><a href="#guidelines_sec02_ssec01_sssec03">GPU-supported texture compression</a></li>
</ul>
</li>
<li class="level2"><a href="#guidelines_sec02_ssec02">Eliminating spatial variation of chromaticity</a></li>
<li class="level2"><a href="#guidelines_sec02_ssec04">Reducing spatial variation for general SVBRDF parameters</a></li>
<li class="level2"><a href="#guidelines_sec02_ssec05">Resource Referencing and Sharing</a></li>
<li class="level2"><a href="#guidelines_sec02_ssec06">Summary</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="guidelines_sec02"></a>
Optimizing Performance and Memory Consumption</h1>
<p>Measured appearance has often been considered as being more resource demanding than tweaked materials based on manually edited texture images. This has been true for BTF-based material representations which rely on dense sampling of both the spatial and the angular dimension of appearance, but it does not apply to measured materials based on the SVBRDF representation. The reason is simply that even hand-tweaked materials are essentially SVBRDFs: every texel stores parameters of a certain BRDF model. As a result most of the optimization techniques which are applied to hand-tweaked materials can also be applied to measured materials with a similar effect.</p>
<p>In these guidelines we focus on the <a class="el" href="page1.html">SVBRDF Representation</a> which is used as default by X-Rite's novel TAC7 device. While the numbers given in the following for illustrating AxF storage requirements are based on SVBRDFs, most of the techniques could also be applied to BTFs and Carpaint representations.</p>
<p>A typical AxF 1.1 anisotropic SVBRDF resulting from a TAC7 measurement consists of the following parameters:</p><ul>
<li>Diffuse Color, \(|T_{c_d}(\mathbf{x})|=3\) channels</li>
<li>Normal Map, \(|T_{N}(\mathbf{x})|=3\) channels</li>
<li>Specular Color, \(|T_{c_s}(\mathbf{x})|=3\) channels</li>
<li>Anisotropic Roughness, \(|T_{p_s}(\mathbf{x})|=3\) channels &#160;&ndash;&#160; Note: In AxF, this is in general represented by two resources, a 2-channel <em>Roughness</em> map (representing roughness values along the two principal axes) and a single-channel <em>Anisotropic Rotation</em> map (containing rotation angles).</li>
<li>Fresnel, \(|T_{F_0}(\mathbf{x})|= 1\) channel</li>
<li>Material dependent:<ul>
<li>Clearcoat Layer IOR, 1 channel</li>
<li>Clearcoat Layer Normal Map, 3 channels <br />
 Without clearcoat, such an SVBRDF has 13 channels and given a spatial resolution of \(1024\times1024\) pixels this leads to \(13 \times 1024 \times 1024 \times 4 = 52 \,\textbf{MB}\) (additional 16 MB for clearcoat) of uncompressed data in 32-bit precision.</li>
</ul>
</li>
</ul>
<p>Note that the storage requirement for the AxF file itself is in general considerably lower, since AxF applies common lossless compression techniques for storing the data. However, this kind of compression is not suitable for random access to the data, thus the data is decompressed transparently when reading it from the AxF file. Therefore, we only consider the uncompressed in-memory storage requirements of AxF materials in the following.</p>
<p>Using roughly 50 MB of storage per material can impose a restriction for the use of AxF materials in real-time applications and on low-performance systems, for instance at the point-of-sale. Fortunately, the in-memory storage requirements can be reduced in numerous ways for most practical applications as described in the following sub-sections.</p>
<h2><a class="anchor" id="guidelines_sec02_ssec01"></a>
Reducing numerical precision</h2>
<p>Full 32-bit precision is almost never required for rendering applications. Numerical precision can be reduced already while requesting data from the AxF file. Further reduction can applied by the client application as needed.</p>
<h3><a class="anchor" id="guidelines_sec02_ssec01_sssec01"></a>
Half-precision floating point format</h3>
<p>Todays GPUs support the so-called half-precision floating point format defined in IEEE standard 754-2008, which uses 16 bits. In fact, it is recommended to request textures from the AxF file in half-precision floating point format using the constant TYPE_HALF as datatype parameter. For 99% of the applications, the difference won't be noticeable and as the datatype's name suggests, storage requirements are halfed arriving at 26 MB per material for our example. Autodesk VRED uses 16-bit precision by default.</p>
<h3><a class="anchor" id="guidelines_sec02_ssec01_sssec02"></a>
Fixed point numbers</h3>
<p>If even further storage reduction is desired, this can be achieved by using an 8-bit fixed point representation for the data values. However, in order to do so, the high-dynamic range floating point data stored in AxF needs to be mapped appropriately to low-dynamic range fixed point values. Since the dynamic range of the different texture types (Color, Normal, Roughness, Fresnel) varies greatly, it is strongly recommended to use different mappings for the different texture types. For some texture types, such as normals and anisotropic rotation, a linear mapping is appropriate. In that case, the valid data range (e.g. \([-1\; 1]\) for normal coordinates or \([-\frac{\pi}{2}\; \frac{\pi}{2}]\) for anisotropic rotation) can simply be mapped linearly to the range of 8-bit integer values. However, for other texture types, in particular color textures, a linear mapping might result in an undesired, clearly visible reduction of precision, so that it is recommendable to use a non-linear mapping instead. Keep in mind that AxF stores color textures in linear color space, since texture filtering and lighting computations should ideally be performed in linear color space. In context of an OpenGL renderer that is in need of a low memory footprint, one option is to convert the texture to the non-linear sRGB color space before uploading it to OpenGL and then to use the OpenGL extension <a href="https://www.opengl.org/registry/specs/EXT/texture_sRGB.txt">GL_EXT_texture_sRGB</a> (also part of the OpenGL 2.1 core), which implicitly converts the texture content back to the original linear color space when accessing it in the shader in order to perform lighting computations in linear color space.</p>
<p>The SDK currently does not support automatic conversion to 8-bit fixed point numbers, but it might be considered for future versions. Until then this task can be implemented by the client application itself when needed. By using 8-bit fixed point numbers the storage requirements can be reduced to 25%, resulting in 13 MB per material for our example calculation.</p>
<h3><a class="anchor" id="guidelines_sec02_ssec01_sssec03"></a>
GPU-supported texture compression</h3>
<p>For applications that are in need of an even lower memory footprint, there are additional options, such as using fixed point formats with less than 8 bits per data value (even though this likely results in noticeable banding artifacts), specific packet texture formats for color or normal textures, or various texture compression techniques. GPU-based texture compression techniques typically work on fixed point textures, although some GPUs support compressed floating point textures as well (see for instance <a href="https://www.opengl.org/registry/specs/ARB/texture_compression_bptc.txt">GL_ARB_texture_compression_bptc</a>). Such techniques will not be supported by the SDK directly, but can be implemented by the client application. <br />
 </p>
<h2><a class="anchor" id="guidelines_sec02_ssec02"></a>
Eliminating spatial variation of chromaticity</h2>
<p>Many real-world materials show mainly intensity variation and much less variation in chromaticity. The very common material class of dielectric materials even has achromatic ("colorless") specular reflections (i.e. highlights always have the color of the light source). Consequently, the storage requirements of the specular color resource can be reduced in case of dielectric materials by storing this resource as single-channel intensity texture. This results in 22 MB per material in the above example (using half-precision floating point). Furthermore, if the material has a single dominant diffuse chromaticity ("unicolor" material), then the diffuse color resource can also be stored as an intensity texture, which then should be multiplied by the dominant color during rendering. If both techniques can be applied, only 9 parameter channels need to be stored in case of an anisotropic SVBRDF without clearcoat (or 7 parameter channels in case of an isotropic SVBRDF).</p>
<p>Currently, automatic reduction of color variation for dielectric materials or "unicolor" materials is not supported by the SDK. Nonetheless, such reductions can be applied either during material measurement / AxF generation by selecting the corresponding material processing parameters (such as assuming the material to be dielectric), or by editing an existing AxF file, for instance via the Editor module in the <b>X-Rite Digital Material Hub</b> (see the figure below), which has built-in functionality to split a multi-channel color resource into a single-channel intensity texture and a uniform (i.e. not spatially varying) multiplier color. Note that the latter operation can sometimes come at the cost of reducing color fidelity (if there actually was some, maybe just subtle chromaticity variation in the original material).</p>
<div class="image">
<img src="MaterialHub.png" alt="MaterialHub.png"/>
<div class="caption">
AxF Editor integrated into X-Rite's Digital Material Hub.</div></div>
<h2><a class="anchor" id="guidelines_sec02_ssec04"></a>
Reducing spatial variation for general SVBRDF parameters</h2>
<p>Generally spatial variation can be reduced by downsampling either the whole SVBRDF (if the full resolution is not required) or individual maps using the AxF Editor. AxF supports that the individual resources of an SVBRDF representation may have different texture sizes (see <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a54db6153d8b9058a1794bfadb26e5e2f" title="Returns the size of the given texture in pixels, the number of channels, and the texture type in whic...">axf::decoding::TextureDecoder::getTextureSize()</a>). This approach is especially recommended if some maps of the SVBRDF have less variation than others. For example, think of a material like single-colored molded plastic, which has an almost constant BRDF but high variation in the normal and/or displacement map.</p>
<p>Furthermore, analogous to the dielectric material option which applys to the specular color map, other parameters might be restricted in the SVBRDF model before fitting. An example is the <em>global F0</em> option which corresponds to an SVBRDF model with a spatially uniform Fresnel parameter.</p>
<h2><a class="anchor" id="guidelines_sec02_ssec05"></a>
Resource Referencing and Sharing</h2>
<p>In product visualization, material variations can often be described by a variation of the material's base color only, such as in case of differently colored plastics or leathers as shown in the figure below. AxF supports to store several variants of a single material in one AxF file, which all reference the same texture resources, but still vary in their uniform resources (for instance in their diffuse base color). This allows to store the texture resources just once for all material variants instead of duplicating them for every variant. <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html" title="Decodes texture resources from AxF representations. ">axf::decoding::TextureDecoder</a> currently does not expose this sharing of resources to the user yet. It is planned to support this feature in one of the next versions.</p>
<div class="image">
<img src="ResourceSharing.png" alt="ResourceSharing.png"/>
<div class="caption">
Two leather materials with different diffuse base color, but sharing the same diffuse and specular intensity map and normal map resources.</div></div>
<h2><a class="anchor" id="guidelines_sec02_ssec06"></a>
Summary</h2>
<p>To conclude, storage requirement optimization can be applied basically in four ways:</p><ol type="1">
<li>Before measurement: By selecting the optimal representation for the material and use case (for instance using the <em>global F0</em> option or the <em>dielectric material</em> assumption).</li>
<li>During data preparation: By using the AxF Editor of X-Rite's Digital Material Hub to reduce the spatial variation in certain BRDF parameters and by using shared AxF resources where appropriate.</li>
<li>While requesting data from the SDK: By choosing an appropriate data type (for instance half-precision floating point) and (maximum) spatial resolution, in which to store textures in memory.</li>
<li>By further reducing the memory footprint of texture resources in the client application, for instance by applying certain texture compression techniques or by supporting sharing of resources.</li>
</ol>
<p>By applying and combining theses techniques, storage reductions from 50%-80% compared to the original 32-bit precision can easily be achieved without losing significant visual fidelity. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 18 2018 00:04:38 for AxF Decoding SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
