<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AxF Decoding SDK: axf::decoding Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="AxF-SDK-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AxF Decoding SDK
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">Decoding AxF representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>axf</b></li><li class="navelem"><a class="el" href="namespaceaxf_1_1decoding.html">decoding</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">axf::decoding Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html">CPUDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes AxF representations on the CPU.  <a href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_sampler.html">Sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples AxF representations on the CPU.  <a href="classaxf_1_1decoding_1_1_sampler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html">TextureDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes texture resources from AxF representations.  <a href="classaxf_1_1decoding_1_1_texture_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aab3bf7ed3e37d2d4d9533682f4ede7cb"><td class="memItemLeft" align="right" valign="top"><a id="aab3bf7ed3e37d2d4d9533682f4ede7cb"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#aab3bf7ed3e37d2d4d9533682f4ede7cb">AxFLoggingCallbackPtr</a>) (int iLogLevel, int iLogContext, const wchar_t *sLogMessage)</td></tr>
<tr class="memdesc:aab3bf7ed3e37d2d4d9533682f4ede7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function pointer type for logging callback function. <br /></td></tr>
<tr class="separator:aab3bf7ed3e37d2d4d9533682f4ede7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab7a5898420f230e93f06d02c3aa2350b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350b">PropertyType</a> { <br />
&#160;&#160;<a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350baee9bb3d9f014bd2699fb69655a2e3bfa">TYPE_HALF</a> = 0, 
<a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba67b225365ac226e253a9af1f37c6e8e1">TYPE_HALF_ARRAY</a> = 1, 
<a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba3f466f5fd483716a0eea0f93ab580962">TYPE_INT</a> = 2, 
<a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350bab84b06ca6591ada0e6b0eec51e40b6df">TYPE_INT_ARRAY</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba935cfd3460d502bd67618a724ef0c9bc">TYPE_FLOAT</a> = 4, 
<a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba88007b5d9b319d3ec7d78dc7fb264071">TYPE_FLOAT_ARRAY</a> = 5, 
<a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350bab3ef80968910f1da814f389311929a54">TYPE_STRING</a> = 7, 
<a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba4505f3a6547d47b52f287a7e9898b169">TYPE_UTF_STRING</a> = 8, 
<br />
&#160;&#160;<a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba4b5c665b819571a5bb9bee611611dc02">TYPE_BOOLEAN</a> = 9
<br />
 }</td></tr>
<tr class="memdesc:ab7a5898420f230e93f06d02c3aa2350b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of property data types used in the metadata retrieval interface and TextureDecoder's property interface.  <a href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350b">More...</a><br /></td></tr>
<tr class="separator:ab7a5898420f230e93f06d02c3aa2350b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac173a11f232e8c93eef53a4e5f071fa2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ac173a11f232e8c93eef53a4e5f071fa2">TextureType</a> { <a class="el" href="namespaceaxf_1_1decoding.html#ac173a11f232e8c93eef53a4e5f071fa2a57ffa7cd08d35de860559c8e6bc2e6b6">TEXTURE_TYPE_HALF</a> = 0, 
<a class="el" href="namespaceaxf_1_1decoding.html#ac173a11f232e8c93eef53a4e5f071fa2a38f03a642533120ec9df83c0aa7ca27d">TEXTURE_TYPE_FLOAT</a> = 4, 
<a class="el" href="namespaceaxf_1_1decoding.html#ac173a11f232e8c93eef53a4e5f071fa2a47e9811df9269fe8e5ee271511a502c7">TEXTURE_TYPE_BYTE</a> = 6
 }</td></tr>
<tr class="memdesc:ac173a11f232e8c93eef53a4e5f071fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of texture types used in TextureDecoder's texture retrieval interface.  <a href="namespaceaxf_1_1decoding.html#ac173a11f232e8c93eef53a4e5f071fa2">More...</a><br /></td></tr>
<tr class="separator:ac173a11f232e8c93eef53a4e5f071fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81aa4ecc3994ce4d0519d103b192c546"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546">ETextureOrigin</a> { <a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546a5a8c2e03f44e80140d7ed828408477c5">ORIGIN_TOPLEFT</a> = 0, 
<a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546af81cf674c1146c260fd907f0794d252b">ORIGIN_BOTTOMLEFT</a> = 1
 }</td></tr>
<tr class="memdesc:a81aa4ecc3994ce4d0519d103b192c546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spatially varying textures need to have a defined embedding into 3D.  <a href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546">More...</a><br /></td></tr>
<tr class="separator:a81aa4ecc3994ce4d0519d103b192c546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee89c80cccc55bedcfd5e354df4b40a7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#aee89c80cccc55bedcfd5e354df4b40a7">ELogLevel</a> { <a class="el" href="namespaceaxf_1_1decoding.html#aee89c80cccc55bedcfd5e354df4b40a7a642ad79a1e85c4651cdf4cce6c833c4d">LOGLEVEL_INFO</a> = 0, 
<a class="el" href="namespaceaxf_1_1decoding.html#aee89c80cccc55bedcfd5e354df4b40a7a96160a38394a16806f64cf0de8d41f1b">LOGLEVEL_WARNING</a> = 1, 
<a class="el" href="namespaceaxf_1_1decoding.html#aee89c80cccc55bedcfd5e354df4b40a7a638409e028368083fa4f72f243a79227">LOGLEVEL_ERROR</a> = 2
 }</td></tr>
<tr class="memdesc:aee89c80cccc55bedcfd5e354df4b40a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log levels for axfEnableLogging() and logging callback.  <a href="namespaceaxf_1_1decoding.html#aee89c80cccc55bedcfd5e354df4b40a7">More...</a><br /></td></tr>
<tr class="separator:aee89c80cccc55bedcfd5e354df4b40a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ffc6ba135b3723b4503b7fa414f191"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ae6ffc6ba135b3723b4503b7fa414f191">ELogContext</a> { <a class="el" href="namespaceaxf_1_1decoding.html#ae6ffc6ba135b3723b4503b7fa414f191ab42771b7b77405fed85968f66f471e34">LOGCONTEXT_AXF_IO</a> = 0, 
<a class="el" href="namespaceaxf_1_1decoding.html#ae6ffc6ba135b3723b4503b7fa414f191a4d3d58ef19c0cc8528c44d5540bd424c">LOGCONTEXT_DECODERS</a> = 1, 
<a class="el" href="namespaceaxf_1_1decoding.html#ae6ffc6ba135b3723b4503b7fa414f191a2d61ee8cce2ae516beb5783ab4fa380c">LOGCONTEXT_GENERIC</a> = 2
 }</td></tr>
<tr class="memdesc:ae6ffc6ba135b3723b4503b7fa414f191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log context indicator for logging callback.  <a href="namespaceaxf_1_1decoding.html#ae6ffc6ba135b3723b4503b7fa414f191">More...</a><br /></td></tr>
<tr class="separator:ae6ffc6ba135b3723b4503b7fa414f191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16895524f5dc85432f79872337ca0659"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a16895524f5dc85432f79872337ca0659">ETargetSystem</a> { <a class="el" href="namespaceaxf_1_1decoding.html#a16895524f5dc85432f79872337ca0659af8ce4fda422da8997469be1a787269a9">ID_DEFAULT</a> = 0, 
<a class="el" href="namespaceaxf_1_1decoding.html#a16895524f5dc85432f79872337ca0659ae5903c1cdba84a56e459bfeb02753ba0">ID_VRED</a> = ID_DEFAULT
 }</td></tr>
<tr class="memdesc:a16895524f5dc85432f79872337ca0659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of different target systems supported by TextureDecoder.  <a href="namespaceaxf_1_1decoding.html#a16895524f5dc85432f79872337ca0659">More...</a><br /></td></tr>
<tr class="separator:a16895524f5dc85432f79872337ca0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Logging</div></td></tr>
<tr class="memitem:a42a3aa2f61db900bcbea3227ac0350c7"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a42a3aa2f61db900bcbea3227ac0350c7">axfEnableLogging</a> (<a class="el" href="namespaceaxf_1_1decoding.html#aab3bf7ed3e37d2d4d9533682f4ede7cb">AxFLoggingCallbackPtr</a> pCallback, int iLogLevel=<a class="el" href="namespaceaxf_1_1decoding.html#aee89c80cccc55bedcfd5e354df4b40a7a642ad79a1e85c4651cdf4cce6c833c4d">LOGLEVEL_INFO</a>)</td></tr>
<tr class="memdesc:a42a3aa2f61db900bcbea3227ac0350c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable logging.  <a href="#a42a3aa2f61db900bcbea3227ac0350c7">More...</a><br /></td></tr>
<tr class="separator:a42a3aa2f61db900bcbea3227ac0350c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8169fae9d47cb210e711ffc58fe1758"><td class="memItemLeft" align="right" valign="top">void AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ad8169fae9d47cb210e711ffc58fe1758">axfDisableLogging</a> ()</td></tr>
<tr class="memdesc:ad8169fae9d47cb210e711ffc58fe1758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable logging.  <a href="#ad8169fae9d47cb210e711ffc58fe1758">More...</a><br /></td></tr>
<tr class="separator:ad8169fae9d47cb210e711ffc58fe1758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Open/Close</div></td></tr>
<tr class="memitem:a2f15e132eb528e19b35a08766ffe1ad5"><td class="memItemLeft" align="right" valign="top">AXF_FILE_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a2f15e132eb528e19b35a08766ffe1ad5">axfOpenFile</a> (const char *sFilename, bool bReadOnly=false, bool bReadLazy=true)</td></tr>
<tr class="memdesc:a2f15e132eb528e19b35a08766ffe1ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an AxF File and return handle.  <a href="#a2f15e132eb528e19b35a08766ffe1ad5">More...</a><br /></td></tr>
<tr class="separator:a2f15e132eb528e19b35a08766ffe1ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf4581e996ae8e1bdbc47275e1b73e2"><td class="memItemLeft" align="right" valign="top">AXF_FILE_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#afdf4581e996ae8e1bdbc47275e1b73e2">axfOpenFileW</a> (const wchar_t *sFilename, bool bReadOnly=false, bool bReadLazy=true)</td></tr>
<tr class="memdesc:afdf4581e996ae8e1bdbc47275e1b73e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an AxF File and return handle.  <a href="#afdf4581e996ae8e1bdbc47275e1b73e2">More...</a><br /></td></tr>
<tr class="separator:afdf4581e996ae8e1bdbc47275e1b73e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8914705b2694e0b5ba515286abcd17e8"><td class="memItemLeft" align="right" valign="top">void AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a8914705b2694e0b5ba515286abcd17e8">axfCloseFile</a> (AXF_FILE_HANDLE *phAxfFile)</td></tr>
<tr class="memdesc:a8914705b2694e0b5ba515286abcd17e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a valid AxF file handle.  <a href="#a8914705b2694e0b5ba515286abcd17e8">More...</a><br /></td></tr>
<tr class="separator:a8914705b2694e0b5ba515286abcd17e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">AxF Materials</div></td></tr>
<tr class="memitem:a822aebf5d5a0bd622dbda16a198b3090"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a822aebf5d5a0bd622dbda16a198b3090">axfGetNumberOfMaterials</a> (AXF_FILE_HANDLE hAxFFile)</td></tr>
<tr class="memdesc:a822aebf5d5a0bd622dbda16a198b3090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of materials stored in the AxF file.  <a href="#a822aebf5d5a0bd622dbda16a198b3090">More...</a><br /></td></tr>
<tr class="separator:a822aebf5d5a0bd622dbda16a198b3090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47c81aea5fa5deffeed2dc7e3f40bad"><td class="memItemLeft" align="right" valign="top">AXF_MATERIAL_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ab47c81aea5fa5deffeed2dc7e3f40bad">axfGetMaterial</a> (AXF_FILE_HANDLE hAxFFile, int iMaterial)</td></tr>
<tr class="memdesc:ab47c81aea5fa5deffeed2dc7e3f40bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to a specific material stored in the AxF file.  <a href="#ab47c81aea5fa5deffeed2dc7e3f40bad">More...</a><br /></td></tr>
<tr class="separator:ab47c81aea5fa5deffeed2dc7e3f40bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2c4753a70c7d6389791b41f5f38dd4"><td class="memItemLeft" align="right" valign="top">AXF_MATERIAL_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a7c2c4753a70c7d6389791b41f5f38dd4">axfGetDefaultMaterial</a> (AXF_FILE_HANDLE hAxFFile)</td></tr>
<tr class="memdesc:a7c2c4753a70c7d6389791b41f5f38dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the <em>default</em> material stored in the AxF file.  <a href="#a7c2c4753a70c7d6389791b41f5f38dd4">More...</a><br /></td></tr>
<tr class="separator:a7c2c4753a70c7d6389791b41f5f38dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfca744e73963e6097b27bca542a045"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a7bfca744e73963e6097b27bca542a045">axfGetMaterialDisplayName</a> (AXF_MATERIAL_HANDLE hAxFMaterial, wchar_t *sBuf, int iBufSize)</td></tr>
<tr class="memdesc:a7bfca744e73963e6097b27bca542a045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the display name of a given material.  <a href="#a7bfca744e73963e6097b27bca542a045">More...</a><br /></td></tr>
<tr class="separator:a7bfca744e73963e6097b27bca542a045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15b05d7447db96c2de30a625cf5f41f"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ae15b05d7447db96c2de30a625cf5f41f">axfGetMaterialIDString</a> (AXF_MATERIAL_HANDLE hAxFMaterial, char *sBuf, int iBufSize)</td></tr>
<tr class="memdesc:ae15b05d7447db96c2de30a625cf5f41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID string of a given material.  <a href="#ae15b05d7447db96c2de30a625cf5f41f">More...</a><br /></td></tr>
<tr class="separator:ae15b05d7447db96c2de30a625cf5f41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1222e8a1951c1829e8261f6e6a09e4"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a8b1222e8a1951c1829e8261f6e6a09e4">axfGetMaterialName</a> (AXF_FILE_HANDLE hAxFFile, int iMaterial, char *sBuf, int iBufSize)</td></tr>
<tr class="memdesc:a8b1222e8a1951c1829e8261f6e6a09e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <em>ID string</em> of a given material (deprecated)  <a href="#a8b1222e8a1951c1829e8261f6e6a09e4">More...</a><br /></td></tr>
<tr class="separator:a8b1222e8a1951c1829e8261f6e6a09e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af993f697149477a50c676f35d7e98532"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#af993f697149477a50c676f35d7e98532">axfGetDefaultMaterialName</a> (AXF_FILE_HANDLE hAxFFile, char *sBuf, int iBufSize)</td></tr>
<tr class="memdesc:af993f697149477a50c676f35d7e98532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <em>ID string</em> of the default material in the AxF file (deprecated)  <a href="#af993f697149477a50c676f35d7e98532">More...</a><br /></td></tr>
<tr class="separator:af993f697149477a50c676f35d7e98532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31e8541080b3df816b34f3e3d23eaa0"><td class="memItemLeft" align="right" valign="top">AXF_MATERIAL_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ab31e8541080b3df816b34f3e3d23eaa0">axfFindMaterialByIDString</a> (AXF_FILE_HANDLE hAxFFile, const char *sMaterialID)</td></tr>
<tr class="memdesc:ab31e8541080b3df816b34f3e3d23eaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the handle to a specific material stored in the AxF file based on its ID string.  <a href="#ab31e8541080b3df816b34f3e3d23eaa0">More...</a><br /></td></tr>
<tr class="separator:ab31e8541080b3df816b34f3e3d23eaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">AxF Material Metadata</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Each material can have a metadata section which allows to store an arbitrary number of metadata documents. </p>
</div></td></tr>
<tr class="memitem:ac50994f4c6beda102ce4ed21b29698ed"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ac50994f4c6beda102ce4ed21b29698ed">axfGetNumberOfMetadataDocuments</a> (AXF_MATERIAL_HANDLE hAxFMaterial)</td></tr>
<tr class="memdesc:ac50994f4c6beda102ce4ed21b29698ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of metadata documents for an AxF material.  <a href="#ac50994f4c6beda102ce4ed21b29698ed">More...</a><br /></td></tr>
<tr class="separator:ac50994f4c6beda102ce4ed21b29698ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6523d3b83b1964635bd4c3cf5dba644"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ae6523d3b83b1964635bd4c3cf5dba644">axfGetNumberOfMetadataDocuments</a> (AXF_FILE_HANDLE hAxFFile, const char *sMaterialID)</td></tr>
<tr class="memdesc:ae6523d3b83b1964635bd4c3cf5dba644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of metadata documents for an AxF material (deprecated)  <a href="#ae6523d3b83b1964635bd4c3cf5dba644">More...</a><br /></td></tr>
<tr class="separator:ae6523d3b83b1964635bd4c3cf5dba644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de7915423992d8a88affaf07d4b1ab2"><td class="memItemLeft" align="right" valign="top">AXF_METADATA_DOCUMENT_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a2de7915423992d8a88affaf07d4b1ab2">axfGetMetadataDocument</a> (AXF_MATERIAL_HANDLE hAxFMaterial, int iMetadataDocument)</td></tr>
<tr class="memdesc:a2de7915423992d8a88affaf07d4b1ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return handle to a material's metadata document.  <a href="#a2de7915423992d8a88affaf07d4b1ab2">More...</a><br /></td></tr>
<tr class="separator:a2de7915423992d8a88affaf07d4b1ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5eeea8b6b643a290631a11b63f5620"><td class="memItemLeft" align="right" valign="top">AXF_METADATA_DOCUMENT_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a8c5eeea8b6b643a290631a11b63f5620">axfGetMetadataDocument</a> (AXF_FILE_HANDLE hAxFFile, const char *sMaterialID, int iMetadataDocument)</td></tr>
<tr class="memdesc:a8c5eeea8b6b643a290631a11b63f5620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return handle to a material's metadata document (deprecated)  <a href="#a8c5eeea8b6b643a290631a11b63f5620">More...</a><br /></td></tr>
<tr class="separator:a8c5eeea8b6b643a290631a11b63f5620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf594ce212173a09924895ae7900037"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#aaaf594ce212173a09924895ae7900037">axfGetMetadataDocumentName</a> (AXF_METADATA_DOCUMENT_HANDLE hAxFMetadataDocument, char *sBuf, int iBufSize)</td></tr>
<tr class="memdesc:aaaf594ce212173a09924895ae7900037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a metadata document stored in the AxF file.  <a href="#aaaf594ce212173a09924895ae7900037">More...</a><br /></td></tr>
<tr class="separator:aaaf594ce212173a09924895ae7900037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01b7a220198faf6eb6b57a2bf6ad018"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ad01b7a220198faf6eb6b57a2bf6ad018">axfGetNumberOfMetadataSubDocuments</a> (AXF_METADATA_DOCUMENT_HANDLE hAxFMetadataDocument)</td></tr>
<tr class="memdesc:ad01b7a220198faf6eb6b57a2bf6ad018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of sub documents for an existing metadata document.  <a href="#ad01b7a220198faf6eb6b57a2bf6ad018">More...</a><br /></td></tr>
<tr class="separator:ad01b7a220198faf6eb6b57a2bf6ad018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d133d8fa0111c068a5338695e0364e"><td class="memItemLeft" align="right" valign="top">AXF_METADATA_DOCUMENT_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a11d133d8fa0111c068a5338695e0364e">axfGetMetadataDataSubDocument</a> (AXF_METADATA_DOCUMENT_HANDLE hAxFMetadataDocument, int iMetadataSubdocument)</td></tr>
<tr class="memdesc:a11d133d8fa0111c068a5338695e0364e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return handle to a metadata subdocument.  <a href="#a11d133d8fa0111c068a5338695e0364e">More...</a><br /></td></tr>
<tr class="separator:a11d133d8fa0111c068a5338695e0364e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9156566933190ea7cfb747141b34e04"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ac9156566933190ea7cfb747141b34e04">axfGetNumberOfMetadataProperties</a> (AXF_METADATA_DOCUMENT_HANDLE hAxFMetadataDocument)</td></tr>
<tr class="memdesc:ac9156566933190ea7cfb747141b34e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of properties for an existing metadata document.  <a href="#ac9156566933190ea7cfb747141b34e04">More...</a><br /></td></tr>
<tr class="separator:ac9156566933190ea7cfb747141b34e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae245435c7f8680479f49f096a77525d7"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ae245435c7f8680479f49f096a77525d7">axfGetMetadataPropertyName</a> (AXF_METADATA_DOCUMENT_HANDLE hAxFMetadataDocument, int iProperty, char *sBuf, int iBufSize)</td></tr>
<tr class="memdesc:ae245435c7f8680479f49f096a77525d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the metadata property.  <a href="#ae245435c7f8680479f49f096a77525d7">More...</a><br /></td></tr>
<tr class="separator:ae245435c7f8680479f49f096a77525d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34570ac7f0b4c9692763f1a97ce996e6"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a34570ac7f0b4c9692763f1a97ce996e6">axfGetMetadataPropertyType</a> (AXF_METADATA_DOCUMENT_HANDLE hAxFMetadataDocument, int iProperty)</td></tr>
<tr class="memdesc:a34570ac7f0b4c9692763f1a97ce996e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the datatype in which a given metadata property is stored in the AxF file.  <a href="#a34570ac7f0b4c9692763f1a97ce996e6">More...</a><br /></td></tr>
<tr class="separator:a34570ac7f0b4c9692763f1a97ce996e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a0d87c3877056743cd10ecd94b3e7a"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a37a0d87c3877056743cd10ecd94b3e7a">axfGetMetadataPropertyValueLen</a> (AXF_METADATA_DOCUMENT_HANDLE hAxFMetadataDocument, int iProperty)</td></tr>
<tr class="memdesc:a37a0d87c3877056743cd10ecd94b3e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length (in number of elements) of the given metadata property value.  <a href="#a37a0d87c3877056743cd10ecd94b3e7a">More...</a><br /></td></tr>
<tr class="separator:a37a0d87c3877056743cd10ecd94b3e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9eaf69372af5d10eb9b47ddfcb21f2"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a5b9eaf69372af5d10eb9b47ddfcb21f2">axfGetMetadataPropertyValue</a> (AXF_METADATA_DOCUMENT_HANDLE hAxFMetadataDocument, int iProperty, int iType, void *pBuf, int iBufSize)</td></tr>
<tr class="memdesc:a5b9eaf69372af5d10eb9b47ddfcb21f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the property value into a user provided buffer.  <a href="#a5b9eaf69372af5d10eb9b47ddfcb21f2">More...</a><br /></td></tr>
<tr class="separator:a5b9eaf69372af5d10eb9b47ddfcb21f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">AxF Representations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The interface provided here offers basic access functionality required to enumerate and select the available representations. Higher level access is provided using the decoder functionality from classes <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html" title="Decodes AxF representations on the CPU. ">CPUDecoder</a> and <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html" title="Decodes texture resources from AxF representations. ">TextureDecoder</a>. </p>
</div></td></tr>
<tr class="memitem:a0d456414df906f81bcc8740e9eb8a7d0"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a0d456414df906f81bcc8740e9eb8a7d0">axfGetNumberOfRepresentations</a> (AXF_MATERIAL_HANDLE hAxFMaterial)</td></tr>
<tr class="memdesc:a0d456414df906f81bcc8740e9eb8a7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of representations stored for an AxF material.  <a href="#a0d456414df906f81bcc8740e9eb8a7d0">More...</a><br /></td></tr>
<tr class="separator:a0d456414df906f81bcc8740e9eb8a7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7beeb59e7ef986a95e9fa45fb7ace3"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a8f7beeb59e7ef986a95e9fa45fb7ace3">axfGetNumberOfRepresentations</a> (AXF_FILE_HANDLE hAxFFile, const char *sMaterialID)</td></tr>
<tr class="memdesc:a8f7beeb59e7ef986a95e9fa45fb7ace3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of representations stored for an AxF material (deprecated)  <a href="#a8f7beeb59e7ef986a95e9fa45fb7ace3">More...</a><br /></td></tr>
<tr class="separator:a8f7beeb59e7ef986a95e9fa45fb7ace3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c04510b187bd2d96d58d4f762e5c3b9"><td class="memItemLeft" align="right" valign="top">AXF_REPRESENTATION_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a3c04510b187bd2d96d58d4f762e5c3b9">axfGetRepresentation</a> (AXF_MATERIAL_HANDLE hAxFMaterial, int iRepresentation)</td></tr>
<tr class="memdesc:a3c04510b187bd2d96d58d4f762e5c3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle to a specific representation of an AxF material.  <a href="#a3c04510b187bd2d96d58d4f762e5c3b9">More...</a><br /></td></tr>
<tr class="separator:a3c04510b187bd2d96d58d4f762e5c3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b43acd4285e2196ac9aa871480afff4"><td class="memItemLeft" align="right" valign="top">AXF_REPRESENTATION_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a7b43acd4285e2196ac9aa871480afff4">axfGetRepresentation</a> (AXF_FILE_HANDLE hAxFFile, const char *sMaterialID, int iRepresentation)</td></tr>
<tr class="memdesc:a7b43acd4285e2196ac9aa871480afff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle to a specific representation of an AxF material (deprecated)  <a href="#a7b43acd4285e2196ac9aa871480afff4">More...</a><br /></td></tr>
<tr class="separator:a7b43acd4285e2196ac9aa871480afff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36755ec273d115909eefb03268beec0c"><td class="memItemLeft" align="right" valign="top">AXF_REPRESENTATION_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a36755ec273d115909eefb03268beec0c">axfGetPreferredRepresentation</a> (AXF_MATERIAL_HANDLE hAxFMaterial)</td></tr>
<tr class="memdesc:a36755ec273d115909eefb03268beec0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle to the preferred supported representation of an AxF material.  <a href="#a36755ec273d115909eefb03268beec0c">More...</a><br /></td></tr>
<tr class="separator:a36755ec273d115909eefb03268beec0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657690f1407af128ac046922b67cd020"><td class="memItemLeft" align="right" valign="top">AXF_REPRESENTATION_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a657690f1407af128ac046922b67cd020">axfGetPreferredRepresentation</a> (AXF_FILE_HANDLE hAxFFile, const char *sMaterialID=0)</td></tr>
<tr class="memdesc:a657690f1407af128ac046922b67cd020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle to the preferred supported representation of an AxF material.  <a href="#a657690f1407af128ac046922b67cd020">More...</a><br /></td></tr>
<tr class="separator:a657690f1407af128ac046922b67cd020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cd171d9aa6a6c53e0ddceb8dd06898"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a57cd171d9aa6a6c53e0ddceb8dd06898">axfGetRepresentationClass</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, char *sBuf, int iBufSize)</td></tr>
<tr class="memdesc:a57cd171d9aa6a6c53e0ddceb8dd06898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <em>RepresentationClass</em>, which classifies the representation as SVBRDF, CarPaint, etc.  <a href="#a57cd171d9aa6a6c53e0ddceb8dd06898">More...</a><br /></td></tr>
<tr class="separator:a57cd171d9aa6a6c53e0ddceb8dd06898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544463086d0f705d06909be912f51ce2"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a544463086d0f705d06909be912f51ce2">axfGetRepresentationTypeKey</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, char *sBuf, int iBufSize)</td></tr>
<tr class="memdesc:a544463086d0f705d06909be912f51ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the <em>TypeKey</em> from the given representation node.  <a href="#a544463086d0f705d06909be912f51ce2">More...</a><br /></td></tr>
<tr class="separator:a544463086d0f705d06909be912f51ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab9ca074e61753d88eddcc0dd00f637"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a6ab9ca074e61753d88eddcc0dd00f637">axfGetRepresentationVariant</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, char *sVariantStringBuf, int iBufSize)</td></tr>
<tr class="memdesc:a6ab9ca074e61753d88eddcc0dd00f637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a string specifying a variant of a given representation.  <a href="#a6ab9ca074e61753d88eddcc0dd00f637">More...</a><br /></td></tr>
<tr class="separator:a6ab9ca074e61753d88eddcc0dd00f637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c61df68c3d99e01b78194f7f25c4363"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a4c61df68c3d99e01b78194f7f25c4363">axfGetRepresentationVersion</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, int &amp;iMajor, int &amp;iMinor, int &amp;iRevision)</td></tr>
<tr class="memdesc:a4c61df68c3d99e01b78194f7f25c4363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the representation's version number.  <a href="#a4c61df68c3d99e01b78194f7f25c4363">More...</a><br /></td></tr>
<tr class="separator:a4c61df68c3d99e01b78194f7f25c4363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0559ae312d5a6ffa572f92d19819385c"><td class="memItemLeft" align="right" valign="top">void AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a0559ae312d5a6ffa572f92d19819385c">axfGetHighestSupportedRepresentationVersion</a> (int &amp;iMajor, int &amp;iMinor)</td></tr>
<tr class="memdesc:a0559ae312d5a6ffa572f92d19819385c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the SDK's highest supported representation version.  <a href="#a0559ae312d5a6ffa572f92d19819385c">More...</a><br /></td></tr>
<tr class="separator:a0559ae312d5a6ffa572f92d19819385c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f7bc70cf6d90d86eb164989e7b8c27"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a17f7bc70cf6d90d86eb164989e7b8c27">axfIsRepresentationSupported</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation)</td></tr>
<tr class="memdesc:a17f7bc70cf6d90d86eb164989e7b8c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if representation is supported by the given SDK.  <a href="#a17f7bc70cf6d90d86eb164989e7b8c27">More...</a><br /></td></tr>
<tr class="separator:a17f7bc70cf6d90d86eb164989e7b8c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3229499828c83f0c934e1c865a452d3"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ac3229499828c83f0c934e1c865a452d3">axfCheckRepresentationCompatibilityProfile</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, const char *sCompatibilityProfile, int iVersion)</td></tr>
<tr class="memdesc:ac3229499828c83f0c934e1c865a452d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if representation fits into the given compatibility profile.  <a href="#ac3229499828c83f0c934e1c865a452d3">More...</a><br /></td></tr>
<tr class="separator:ac3229499828c83f0c934e1c865a452d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7dcab437aaed39f39005fb303f7ddc"><td class="memItemLeft" align="right" valign="top">AXF_REPRESENTATION_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a5a7dcab437aaed39f39005fb303f7ddc">axfGetCarPaintFlakesBtfRepresentation</a> (AXF_REPRESENTATION_HANDLE hAxFCarPaintRepresentation)</td></tr>
<tr class="memdesc:a5a7dcab437aaed39f39005fb303f7ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an AxF representation (of representation class <em>CarPaint</em> or <em>CarPaint2</em>), retrieve the child representation for the flakes.  <a href="#a5a7dcab437aaed39f39005fb303f7ddc">More...</a><br /></td></tr>
<tr class="separator:a5a7dcab437aaed39f39005fb303f7ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89bfa6d36f34e0d4ab14a89a5c96943"><td class="memItemLeft" align="right" valign="top">AXF_REPRESENTATION_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ac89bfa6d36f34e0d4ab14a89a5c96943">axfGetCarPaintTabulatedBrdfRepresentation</a> (AXF_REPRESENTATION_HANDLE hAxFCarPaintRepresentation)</td></tr>
<tr class="memdesc:ac89bfa6d36f34e0d4ab14a89a5c96943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an AxF representation (of representation class <em>CarPaint</em> or <em>CarPaint2</em>), retrieve the child representation for the tabulated BRDF component.  <a href="#ac89bfa6d36f34e0d4ab14a89a5c96943">More...</a><br /></td></tr>
<tr class="separator:ac89bfa6d36f34e0d4ab14a89a5c96943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbc9210d9c3801de81fb22d4cd9ed43"><td class="memItemLeft" align="right" valign="top">AXF_REPRESENTATION_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a5dbc9210d9c3801de81fb22d4cd9ed43">axfGetSvbrdfDiffuseModelRepresentation</a> (AXF_REPRESENTATION_HANDLE hAxFSvbrdfRepresentation)</td></tr>
<tr class="memdesc:a5dbc9210d9c3801de81fb22d4cd9ed43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an AxF representation (of representation class <em>SVBRDF</em>, <em>CarPaint</em>, or <em>CarPaint2</em>), retrieve the child representation for the diffuse component of the BRDF model.  <a href="#a5dbc9210d9c3801de81fb22d4cd9ed43">More...</a><br /></td></tr>
<tr class="separator:a5dbc9210d9c3801de81fb22d4cd9ed43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736a18d854555b7a29eb38dade7f538c"><td class="memItemLeft" align="right" valign="top">AXF_REPRESENTATION_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a736a18d854555b7a29eb38dade7f538c">axfGetSvbrdfSpecularModelRepresentation</a> (AXF_REPRESENTATION_HANDLE hAxFSvbrdfRepresentation)</td></tr>
<tr class="memdesc:a736a18d854555b7a29eb38dade7f538c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an AxF representation (of representation class <em>SVBRDF</em>, <em>CarPaint</em>, or <em>CarPaint2</em>), retrieve the child representation for the specular component of the BRDF model.  <a href="#a736a18d854555b7a29eb38dade7f538c">More...</a><br /></td></tr>
<tr class="separator:a736a18d854555b7a29eb38dade7f538c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9260fc8b8fba5f1cc449f9557ed4e199"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a9260fc8b8fba5f1cc449f9557ed4e199">axfGetSvbrdfSpecularModelVariant</a> (AXF_REPRESENTATION_HANDLE hAxFSpecularModelRepresentation, char *sVariantStringBuf, int iBufSize, bool &amp;bIsAnisotropic, bool &amp;bHasFresnel)</td></tr>
<tr class="memdesc:a9260fc8b8fba5f1cc449f9557ed4e199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a string and a few flags identifying the variant of the specular model represented in the AxF file.  <a href="#a9260fc8b8fba5f1cc449f9557ed4e199">More...</a><br /></td></tr>
<tr class="separator:a9260fc8b8fba5f1cc449f9557ed4e199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dc1b612b112141e79a835e93b56697"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a25dc1b612b112141e79a835e93b56697">axfGetSvbrdfSpecularFresnelVariant</a> (AXF_REPRESENTATION_HANDLE hAxFSpecularModelRepresentation, char *sVariantStringBuf, int iBufSize)</td></tr>
<tr class="memdesc:a25dc1b612b112141e79a835e93b56697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a string identifying the variant of the used Fresnel approximation.  <a href="#a25dc1b612b112141e79a835e93b56697">More...</a><br /></td></tr>
<tr class="separator:a25dc1b612b112141e79a835e93b56697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">AxF representation resources</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All data that is used by an AxF representation during evaluation i.e. rendering is called a <em>resource</em>. Typically resources are model parameters like gloss exponents or measurements like intensities, colors, spectra etc. and are thus stored as x-D arrays of floating point values.</p>
<p>AxF stores all resources for a material within a material resource collection that is shared by all representations of the material. Each representation <em>references</em> some (or all) resources from that material resource collection via a so-called <em>lookup operator</em>. The name of this lookup operator defines the <em>semantic</em> of the respective resource for the given representation, i.e. which model parameter of the given representation it represents. </p>
</div></td></tr>
<tr class="memitem:a304496f0d45dba2d7ce426580f97aa3d"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a304496f0d45dba2d7ce426580f97aa3d">axfGetNumberOfRepresentationResources</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation)</td></tr>
<tr class="memdesc:a304496f0d45dba2d7ce426580f97aa3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of (unique) resources that are referenced by a representation (or its sub-representations)  <a href="#a304496f0d45dba2d7ce426580f97aa3d">More...</a><br /></td></tr>
<tr class="separator:a304496f0d45dba2d7ce426580f97aa3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5f1c0e4db091044fdedeb2fe31c128"><td class="memItemLeft" align="right" valign="top">AXF_RESOURCE_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a6a5f1c0e4db091044fdedeb2fe31c128">axfGetRepresentationResourceFromIndex</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, int iResource)</td></tr>
<tr class="memdesc:a6a5f1c0e4db091044fdedeb2fe31c128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return handle to a representation's resource by index.  <a href="#a6a5f1c0e4db091044fdedeb2fe31c128">More...</a><br /></td></tr>
<tr class="separator:a6a5f1c0e4db091044fdedeb2fe31c128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b624485b1c35882434f279a03c83db"><td class="memItemLeft" align="right" valign="top">AXF_RESOURCE_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ac5b624485b1c35882434f279a03c83db">axfGetRepresentationResourceFromLookupPath</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, const char *sLookupPath)</td></tr>
<tr class="memdesc:ac5b624485b1c35882434f279a03c83db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return handle to a representation's resource from a "lookup path".  <a href="#ac5b624485b1c35882434f279a03c83db">More...</a><br /></td></tr>
<tr class="separator:ac5b624485b1c35882434f279a03c83db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adada11879d18bd23c358aa97d50816b0"><td class="memItemLeft" align="right" valign="top">AXF_RESOURCE_HANDLE AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#adada11879d18bd23c358aa97d50816b0">axfGetRepresentationResourceFromLookupName</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, const char *sLookupName, bool bSearchRecursive=true)</td></tr>
<tr class="memdesc:adada11879d18bd23c358aa97d50816b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return handle to a representation's resource from a "lookup name".  <a href="#adada11879d18bd23c358aa97d50816b0">More...</a><br /></td></tr>
<tr class="separator:adada11879d18bd23c358aa97d50816b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119f5814787f0ac52d8060f5b6b24d35"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a119f5814787f0ac52d8060f5b6b24d35">axfGetResourceLookupPath</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, AXF_RESOURCE_HANDLE hAxFResource, char *sBuf, int iBufSize)</td></tr>
<tr class="memdesc:a119f5814787f0ac52d8060f5b6b24d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a resource's "lookup path".  <a href="#a119f5814787f0ac52d8060f5b6b24d35">More...</a><br /></td></tr>
<tr class="separator:a119f5814787f0ac52d8060f5b6b24d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae646a651409d5522692c6679bd1a837a"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ae646a651409d5522692c6679bd1a837a">axfGetResourceNodePath</a> (AXF_RESOURCE_HANDLE hAxFResource, char *sBuf, int iBufSize)</td></tr>
<tr class="memdesc:ae646a651409d5522692c6679bd1a837a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a resource's node path.  <a href="#ae646a651409d5522692c6679bd1a837a">More...</a><br /></td></tr>
<tr class="separator:ae646a651409d5522692c6679bd1a837a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10db6a8b43694d187367c0747fe6b67"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ad10db6a8b43694d187367c0747fe6b67">axfGetResourceDataNumDims</a> (AXF_RESOURCE_HANDLE hAxFResource)</td></tr>
<tr class="memdesc:ad10db6a8b43694d187367c0747fe6b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of dimensions of the resource data.  <a href="#ad10db6a8b43694d187367c0747fe6b67">More...</a><br /></td></tr>
<tr class="separator:ad10db6a8b43694d187367c0747fe6b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11de2ff8af762b47ef90c0085e32d967"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a11de2ff8af762b47ef90c0085e32d967">axfGetResourceDataDimExtent</a> (AXF_RESOURCE_HANDLE hAxFResource, int iDim)</td></tr>
<tr class="memdesc:a11de2ff8af762b47ef90c0085e32d967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the extent of a given dimension of resource data.  <a href="#a11de2ff8af762b47ef90c0085e32d967">More...</a><br /></td></tr>
<tr class="separator:a11de2ff8af762b47ef90c0085e32d967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6121c70ddeb1237aeb24656c735e9374"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a6121c70ddeb1237aeb24656c735e9374">axfGetResourceDataNumElems</a> (AXF_RESOURCE_HANDLE hAxFResource)</td></tr>
<tr class="memdesc:a6121c70ddeb1237aeb24656c735e9374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the total number of elements in the resource i.e. the enrolled extensions along each dimensions.  <a href="#a6121c70ddeb1237aeb24656c735e9374">More...</a><br /></td></tr>
<tr class="separator:a6121c70ddeb1237aeb24656c735e9374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce0753fab1074e5e534850aa0cf1bdd"><td class="memItemLeft" align="right" valign="top">int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a9ce0753fab1074e5e534850aa0cf1bdd">axfGetResourceData</a> (AXF_RESOURCE_HANDLE hAxFResource, float *pfBuffer, int iBufSize)</td></tr>
<tr class="memdesc:a9ce0753fab1074e5e534850aa0cf1bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the resource data into the provided buffer.  <a href="#a9ce0753fab1074e5e534850aa0cf1bdd">More...</a><br /></td></tr>
<tr class="separator:a9ce0753fab1074e5e534850aa0cf1bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">AxF representation preview images</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="PreviewImages"></a> Access to preview images that are stored in the AxF file for a certain representation. Note that AxF preview images are evaluated SVBRDFs (for a certain geometry and lighting condition), i.e. a texture of linear reflectance values, premultiplied with &lt;N,L&gt;, though not yet multiplied with the light color (and not yet mapped to a non-linear display color space). </p>
</div></td></tr>
<tr class="memitem:ade4737a0b3edb38f18ca5f5d44e1b1b9"><td class="memItemLeft" align="right" valign="top"><a id="ade4737a0b3edb38f18ca5f5d44e1b1b9"></a>
int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><b>axfGetNumPreviewImages</b> (AXF_REPRESENTATION_HANDLE hAxFRepresentation)</td></tr>
<tr class="separator:ade4737a0b3edb38f18ca5f5d44e1b1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c3b1aa52f291ff2f85ded5d3a8c9dc"><td class="memItemLeft" align="right" valign="top"><a id="a44c3b1aa52f291ff2f85ded5d3a8c9dc"></a>
int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><b>axfGetPreviewImageName</b> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, int iImageIdx, char *sBuf, int iBufSize)</td></tr>
<tr class="separator:a44c3b1aa52f291ff2f85ded5d3a8c9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e437bf6aef5dbeae136a266f30f365"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a24e437bf6aef5dbeae136a266f30f365">axfGetPreviewImageInfo</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, int iImageIdx, int &amp;iWidth, int &amp;iHeight, int &amp;iChannels, float &amp;fWidthMM, float &amp;fHeightMM)</td></tr>
<tr class="memdesc:a24e437bf6aef5dbeae136a266f30f365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve information about a representation preview image.  <a href="#a24e437bf6aef5dbeae136a266f30f365">More...</a><br /></td></tr>
<tr class="separator:a24e437bf6aef5dbeae136a266f30f365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae251ba22615aab7acd58f0240b660257"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#ae251ba22615aab7acd58f0240b660257">axfGetPreviewImage</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, int iImageIdx, const char *sTargetColorSpace, float *pImage, int iWidth, int iHeight, int iChannels, int iTextureOrigin=<a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546af81cf674c1146c260fd907f0794d252b">ORIGIN_BOTTOMLEFT</a>)</td></tr>
<tr class="memdesc:ae251ba22615aab7acd58f0240b660257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a representation preview image into a user provided buffer.  <a href="#ae251ba22615aab7acd58f0240b660257">More...</a><br /></td></tr>
<tr class="separator:ae251ba22615aab7acd58f0240b660257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3beaa13f163b7af1f5651a565e4eb1"><td class="memItemLeft" align="right" valign="top"><a id="afc3beaa13f163b7af1f5651a565e4eb1"></a>
bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#afc3beaa13f163b7af1f5651a565e4eb1">axfGetPreviewImage</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, int iImageIdx, const char *sTargetColorSpace, float *pImage, int iTextureOrigin=<a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546af81cf674c1146c260fd907f0794d252b">ORIGIN_BOTTOMLEFT</a>)</td></tr>
<tr class="memdesc:afc3beaa13f163b7af1f5651a565e4eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED variant of the function: equivalent to axfGetPreviewImage(hAxFRepresentation, iImageIdx, sTargetColorSpace, pImage, iWidth, iHeight, iChannels, iTextureOrigin) with iWidth, iHeight, and iChannels as returned by <a class="el" href="namespaceaxf_1_1decoding.html#a24e437bf6aef5dbeae136a266f30f365" title="Retrieve information about a representation preview image. ">axfGetPreviewImageInfo()</a> <br /></td></tr>
<tr class="separator:afc3beaa13f163b7af1f5651a565e4eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae8b5adfb8f4d26ac89649f9ed52e35"><td class="memItemLeft" align="right" valign="top"><a id="a0ae8b5adfb8f4d26ac89649f9ed52e35"></a>
int AXF_API&#160;</td><td class="memItemRight" valign="bottom"><b>axfStorePreviewImage</b> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, const float *pImage, int iWidth, int iHeight, int iChannels, float fWidthMM, float fHeightMM, const char *sSourceColorSpace, int iTextureOrigin=<a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546af81cf674c1146c260fd907f0794d252b">ORIGIN_BOTTOMLEFT</a>, const char *sName=AXF_PREVIEW_IMAGE_NAME_DEFAULT)</td></tr>
<tr class="separator:a0ae8b5adfb8f4d26ac89649f9ed52e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">AxF spectral information</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Retrieve spectral information about a representation. </p>
</div></td></tr>
<tr class="memitem:a09fd2908f12def53a464dcf61f17cef8"><td class="memItemLeft" align="right" valign="top">bool AXF_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceaxf_1_1decoding.html#a09fd2908f12def53a464dcf61f17cef8">axfGetSpectralizationTrafo</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, const float *vSpectralSampling, int iNumSpectralSamples, float *pMatrix, const char *sSourceColorSpace)</td></tr>
<tr class="memdesc:a09fd2908f12def53a464dcf61f17cef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a material-dependent linear transformation from a (linear) source color space to the spectral space (for a given spectral sampling).  <a href="#a09fd2908f12def53a464dcf61f17cef8">More...</a><br /></td></tr>
<tr class="separator:a09fd2908f12def53a464dcf61f17cef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace includes functionality required for reading and decoding AxF representations. It is exported as a C-only interface for maximum portability. Nevertheless, for convenience this version of the decoding interface uses C++ language elements. The C-only version is available on request. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ab7a5898420f230e93f06d02c3aa2350b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a5898420f230e93f06d02c3aa2350b">&#9670;&nbsp;</a></span>PropertyType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350b">axf::decoding::PropertyType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab7a5898420f230e93f06d02c3aa2350baee9bb3d9f014bd2699fb69655a2e3bfa"></a>TYPE_HALF&#160;</td><td class="fielddoc"><p>16-bit IEEE half-precision floating point (not yet used for properties) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7a5898420f230e93f06d02c3aa2350ba67b225365ac226e253a9af1f37c6e8e1"></a>TYPE_HALF_ARRAY&#160;</td><td class="fielddoc"><p>array of TYPE_HALF </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7a5898420f230e93f06d02c3aa2350ba3f466f5fd483716a0eea0f93ab580962"></a>TYPE_INT&#160;</td><td class="fielddoc"><p>32-bit signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7a5898420f230e93f06d02c3aa2350bab84b06ca6591ada0e6b0eec51e40b6df"></a>TYPE_INT_ARRAY&#160;</td><td class="fielddoc"><p>array of TYPE_INT </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7a5898420f230e93f06d02c3aa2350ba935cfd3460d502bd67618a724ef0c9bc"></a>TYPE_FLOAT&#160;</td><td class="fielddoc"><p>32-bit IEEE single-precision floating point </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7a5898420f230e93f06d02c3aa2350ba88007b5d9b319d3ec7d78dc7fb264071"></a>TYPE_FLOAT_ARRAY&#160;</td><td class="fielddoc"><p>array of TYPE_FLOAT </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7a5898420f230e93f06d02c3aa2350bab3ef80968910f1da814f389311929a54"></a>TYPE_STRING&#160;</td><td class="fielddoc"><p>null-terminated array of 8-bit characters, representing a string in ISO-8859-1 (Latin-1) encoding </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7a5898420f230e93f06d02c3aa2350ba4505f3a6547d47b52f287a7e9898b169"></a>TYPE_UTF_STRING&#160;</td><td class="fielddoc"><p>null-terminated array of wchar_t characters, representing a string in UTF-16 encoding (Windows) or UTF-32 encoding (Linux/Mac) </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7a5898420f230e93f06d02c3aa2350ba4b5c665b819571a5bb9bee611611dc02"></a>TYPE_BOOLEAN&#160;</td><td class="fielddoc"><p>8-bit boolean </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_ax_f__basic__io_8h_source.html#l00155">155</a> of file <a class="el" href="_ax_f__basic__io_8h_source.html">AxF_basic_io.h</a>.</p>

</div>
</div>
<a id="ac173a11f232e8c93eef53a4e5f071fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac173a11f232e8c93eef53a4e5f071fa2">&#9670;&nbsp;</a></span>TextureType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaxf_1_1decoding.html#ac173a11f232e8c93eef53a4e5f071fa2">axf::decoding::TextureType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac173a11f232e8c93eef53a4e5f071fa2a57ffa7cd08d35de860559c8e6bc2e6b6"></a>TEXTURE_TYPE_HALF&#160;</td><td class="fielddoc"><p>texture of 16-bit IEEE half-precision floating point values </p>
</td></tr>
<tr><td class="fieldname"><a id="ac173a11f232e8c93eef53a4e5f071fa2a38f03a642533120ec9df83c0aa7ca27d"></a>TEXTURE_TYPE_FLOAT&#160;</td><td class="fielddoc"><p>texture of 32-bit IEEE single-precision floating point values </p>
</td></tr>
<tr><td class="fieldname"><a id="ac173a11f232e8c93eef53a4e5f071fa2a47e9811df9269fe8e5ee271511a502c7"></a>TEXTURE_TYPE_BYTE&#160;</td><td class="fielddoc"><p>texture of 8-bit unsigned integer values </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_ax_f__basic__io_8h_source.html#l00170">170</a> of file <a class="el" href="_ax_f__basic__io_8h_source.html">AxF_basic_io.h</a>.</p>

</div>
</div>
<a id="a81aa4ecc3994ce4d0519d103b192c546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81aa4ecc3994ce4d0519d103b192c546">&#9670;&nbsp;</a></span>ETextureOrigin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546">axf::decoding::ETextureOrigin</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appearance data like BTF images or SVBRDFs is implicitly embedded into a local 3D coordinate system which is usually placed in one of the corners of the images. The xy directions of this system are aligned with plane defined by the 2D image coordinate system and the z direction points up into 3D space. This system defines how directions like a light source direction are interpreted.</p>
<p>Most rendering applications define a local coordinate system at each point where shading calculations are performed (usually called <em>local tangent space</em>). This space needs to match the aforementioned material's local coordinate system. AxF allows to query spatial varying appearance data with two different coordinate systems:</p><ol type="1">
<li>top left image corner</li>
<li>bottom left image corner</li>
</ol>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a81aa4ecc3994ce4d0519d103b192c546a5a8c2e03f44e80140d7ed828408477c5"></a>ORIGIN_TOPLEFT&#160;</td><td class="fielddoc"><p>Local coordinate system placed in top left corner. </p>
</td></tr>
<tr><td class="fieldname"><a id="a81aa4ecc3994ce4d0519d103b192c546af81cf674c1146c260fd907f0794d252b"></a>ORIGIN_BOTTOMLEFT&#160;</td><td class="fielddoc"><p>Local coordinate system placed in bottom left corner. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_ax_f__basic__io_8h_source.html#l00191">191</a> of file <a class="el" href="_ax_f__basic__io_8h_source.html">AxF_basic_io.h</a>.</p>

</div>
</div>
<a id="aee89c80cccc55bedcfd5e354df4b40a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee89c80cccc55bedcfd5e354df4b40a7">&#9670;&nbsp;</a></span>ELogLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaxf_1_1decoding.html#aee89c80cccc55bedcfd5e354df4b40a7">axf::decoding::ELogLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aee89c80cccc55bedcfd5e354df4b40a7a642ad79a1e85c4651cdf4cce6c833c4d"></a>LOGLEVEL_INFO&#160;</td><td class="fielddoc"><p>Informational messages. </p>
</td></tr>
<tr><td class="fieldname"><a id="aee89c80cccc55bedcfd5e354df4b40a7a96160a38394a16806f64cf0de8d41f1b"></a>LOGLEVEL_WARNING&#160;</td><td class="fielddoc"><p>Warning messages. </p>
</td></tr>
<tr><td class="fieldname"><a id="aee89c80cccc55bedcfd5e354df4b40a7a638409e028368083fa4f72f243a79227"></a>LOGLEVEL_ERROR&#160;</td><td class="fielddoc"><p>Error messages. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_ax_f__basic__io_8h_source.html#l00199">199</a> of file <a class="el" href="_ax_f__basic__io_8h_source.html">AxF_basic_io.h</a>.</p>

</div>
</div>
<a id="ae6ffc6ba135b3723b4503b7fa414f191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ffc6ba135b3723b4503b7fa414f191">&#9670;&nbsp;</a></span>ELogContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaxf_1_1decoding.html#ae6ffc6ba135b3723b4503b7fa414f191">axf::decoding::ELogContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae6ffc6ba135b3723b4503b7fa414f191ab42771b7b77405fed85968f66f471e34"></a>LOGCONTEXT_AXF_IO&#160;</td><td class="fielddoc"><p>Log message is related to basic AxF file IO. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6ffc6ba135b3723b4503b7fa414f191a4d3d58ef19c0cc8528c44d5540bd424c"></a>LOGCONTEXT_DECODERS&#160;</td><td class="fielddoc"><p>Log message is related to the use of <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html" title="Decodes AxF representations on the CPU. ">CPUDecoder</a> or <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html" title="Decodes texture resources from AxF representations. ">TextureDecoder</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6ffc6ba135b3723b4503b7fa414f191a2d61ee8cce2ae516beb5783ab4fa380c"></a>LOGCONTEXT_GENERIC&#160;</td><td class="fielddoc"><p>Log message is related to the SDK in general. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_ax_f__basic__io_8h_source.html#l00207">207</a> of file <a class="el" href="_ax_f__basic__io_8h_source.html">AxF_basic_io.h</a>.</p>

</div>
</div>
<a id="a16895524f5dc85432f79872337ca0659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16895524f5dc85432f79872337ca0659">&#9670;&nbsp;</a></span>ETargetSystem</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceaxf_1_1decoding.html#a16895524f5dc85432f79872337ca0659">axf::decoding::ETargetSystem</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>Deprecated - use always ID_DEFAULT </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a16895524f5dc85432f79872337ca0659af8ce4fda422da8997469be1a787269a9"></a>ID_DEFAULT&#160;</td><td class="fielddoc"><p>The default system ID to be used all client applications unless indicated otherwise. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16895524f5dc85432f79872337ca0659ae5903c1cdba84a56e459bfeb02753ba0"></a>ID_VRED&#160;</td><td class="fielddoc"><p>Autodesk VRED. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_texture_decoder_8h_source.html#l00040">40</a> of file <a class="el" href="_texture_decoder_8h_source.html">TextureDecoder.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a42a3aa2f61db900bcbea3227ac0350c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a3aa2f61db900bcbea3227ac0350c7">&#9670;&nbsp;</a></span>axfEnableLogging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfEnableLogging </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaxf_1_1decoding.html#aab3bf7ed3e37d2d4d9533682f4ede7cb">AxFLoggingCallbackPtr</a>&#160;</td>
          <td class="paramname"><em>pCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iLogLevel</em> = <code><a class="el" href="namespaceaxf_1_1decoding.html#aee89c80cccc55bedcfd5e354df4b40a7a642ad79a1e85c4651cdf4cce6c833c4d">LOGLEVEL_INFO</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if successful</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallback</td><td>Pointer to callback a function of signature: void callback_func(int iLogLevel, int iLogContext, const char* sLogMessage) </td></tr>
    <tr><td class="paramname">iLogLevel</td><td>The minimum level for log messages (i.e. LOGLEVEL_INFO shows all messages, LOGLEVEL_WARNING warning and error messages, and LOGLEVEL_ERROR only error messages)</td></tr>
  </table>
  </dd>
</dl>
<p>This function can be used to enable logging, for instance for debugging purposes. (By default, logging is disabled.) It calls the specified callback function for each log message (cf. sample code). </p>

</div>
</div>
<a id="ad8169fae9d47cb210e711ffc58fe1758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8169fae9d47cb210e711ffc58fe1758">&#9670;&nbsp;</a></span>axfDisableLogging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AXF_API axf::decoding::axfDisableLogging </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function disables the logging again. </p>

</div>
</div>
<a id="a2f15e132eb528e19b35a08766ffe1ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f15e132eb528e19b35a08766ffe1ad5">&#9670;&nbsp;</a></span>axfOpenFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_FILE_HANDLE AXF_API axf::decoding::axfOpenFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bReadOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bReadLazy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sFilename</td><td>Path to AxF file (in the 8-bit encoding that is used by the standard C/C++ file APIs) </td></tr>
    <tr><td class="paramname">bReadOnly</td><td>Open as read only </td></tr>
    <tr><td class="paramname">bReadLazy</td><td>Only read header on first access. Read data on demand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to AxF file to be used in subsequent calls.</dd></dl>
<p>This function expects the path in the 8-bit encoding that is used by the standard C/C++ file APIs. Note: In case of Mac OS X, this is specified as UTF-8. However, in case of Windows this is a system-locale-dependent, non-Unicode encoding (see MSDN, for instance AreFileAPIsANSI(), for details), which in general can only represent a subset of the characters supported by the character encoding of the Windows filesystem (UTF-16). Therefore, on Windows it is more recommendable to use <a class="el" href="namespaceaxf_1_1decoding.html#afdf4581e996ae8e1bdbc47275e1b73e2" title="Open an AxF File and return handle. ">axfOpenFileW()</a> instead.</p>
<p>After usage the AxF file handle has to be closed using <a class="el" href="namespaceaxf_1_1decoding.html#a8914705b2694e0b5ba515286abcd17e8" title="Closes a valid AxF file handle. ">axfCloseFile()</a>. </p>

</div>
</div>
<a id="afdf4581e996ae8e1bdbc47275e1b73e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf4581e996ae8e1bdbc47275e1b73e2">&#9670;&nbsp;</a></span>axfOpenFileW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_FILE_HANDLE AXF_API axf::decoding::axfOpenFileW </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>sFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bReadOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bReadLazy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sFilename</td><td>Path to AxF file (in 16- or 32-bit Unicode encoding, according to the compiler's wchar_t definition) </td></tr>
    <tr><td class="paramname">bReadOnly</td><td>Open as read only </td></tr>
    <tr><td class="paramname">bReadLazy</td><td>Only read header on first access. Read data on demand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to AxF file to be used in subsequent calls.</dd></dl>
<p>Unicode version of <a class="el" href="namespaceaxf_1_1decoding.html#a2f15e132eb528e19b35a08766ffe1ad5" title="Open an AxF File and return handle. ">axfOpenFile()</a>, which expects the path in UTF-16 encoding on Windows or in UCS-4/UTF-32 encoding on Linux/Mac. Note: In case of Windows, this corresponds to native character encoding of the filesystem and thus maps directly to the Windows wide-char file APIs. For Linux and Mac, which do not have wide-char file APIs, this function tries to translate the Unicode representation of the path to the native 8-bit character encoding of the filesystem and calls <a class="el" href="namespaceaxf_1_1decoding.html#a2f15e132eb528e19b35a08766ffe1ad5" title="Open an AxF File and return handle. ">axfOpenFile()</a> on that. However, for Linux this conversion is not fully well-defined, as the filesystem's encoding is in general not well-specified there (the current implementation uses the system locale on Linux like e.g. boost::filesystem does; so this may or may not work as expected on that system). Therefore, on Linux it is in general more recommendable to use <a class="el" href="namespaceaxf_1_1decoding.html#a2f15e132eb528e19b35a08766ffe1ad5" title="Open an AxF File and return handle. ">axfOpenFile()</a> directly instead.</p>
<p>After usage the AxF file handle has to be closed using <a class="el" href="namespaceaxf_1_1decoding.html#a8914705b2694e0b5ba515286abcd17e8" title="Closes a valid AxF file handle. ">axfCloseFile()</a>. </p>

</div>
</div>
<a id="a8914705b2694e0b5ba515286abcd17e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8914705b2694e0b5ba515286abcd17e8">&#9670;&nbsp;</a></span>axfCloseFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AXF_API axf::decoding::axfCloseFile </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE *&#160;</td>
          <td class="paramname"><em>phAxfFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phAxfFile</td><td>Pointer to valid AxF file handle</td></tr>
  </table>
  </dd>
</dl>
<p>After closing the file handle all other open handles retrieved for the file become invalid. </p>

</div>
</div>
<a id="a822aebf5d5a0bd622dbda16a198b3090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822aebf5d5a0bd622dbda16a198b3090">&#9670;&nbsp;</a></span>axfGetNumberOfMaterials()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetNumberOfMaterials </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFFile</td><td>Handle to open AxF File </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of materials stored in the AxF file</dd></dl>
<p>Each AxF file stores a certain number of <em>materials</em>. An AxF material can represent for instance a measured real-world material, and edited version of it, or some virtual material. </p>

</div>
</div>
<a id="ab47c81aea5fa5deffeed2dc7e3f40bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab47c81aea5fa5deffeed2dc7e3f40bad">&#9670;&nbsp;</a></span>axfGetMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_MATERIAL_HANDLE AXF_API axf::decoding::axfGetMaterial </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iMaterial</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFFile</td><td>Handle to open AxF file </td></tr>
    <tr><td class="paramname">iMaterial</td><td>Index of the material in the file (in range 0 .. <a class="el" href="namespaceaxf_1_1decoding.html#a822aebf5d5a0bd622dbda16a198b3090" title="Get the number of materials stored in the AxF file. ">axfGetNumberOfMaterials()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to material (or zero) </dd></dl>

</div>
</div>
<a id="a7c2c4753a70c7d6389791b41f5f38dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2c4753a70c7d6389791b41f5f38dd4">&#9670;&nbsp;</a></span>axfGetDefaultMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_MATERIAL_HANDLE AXF_API axf::decoding::axfGetDefaultMaterial </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFFile</td><td>Handle to open AxF file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to found material (or zero)</dd></dl>
<p>AxF files may have a designated default material. This is implicitly the case for AxF files consisting of a single material only. AxF files with multiple materials might also have a designated default material, for instance if there is a layered material which references all other materials in the file as layers.</p>
<p>If the AxF files contains multiple materials without a designated default material, this function fails with return value 0. In that case the desired material handle needs to be queried via <a class="el" href="namespaceaxf_1_1decoding.html#ab47c81aea5fa5deffeed2dc7e3f40bad" title="Get a handle to a specific material stored in the AxF file. ">axfGetMaterial()</a>.</p>
<p>For AxF files with multiple materials in general some kind of user interaction is recommended to allow the user choosing a material (at least when there is no designated default material). The default material, if existing, is useful for instance to preselect a material in case of user interaction, or to autonomously choose a material from the file without user interaction (such as to choose a preview image that is representative for the full AxF file). </p>

</div>
</div>
<a id="a7bfca744e73963e6097b27bca542a045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfca744e73963e6097b27bca542a045">&#9670;&nbsp;</a></span>axfGetMaterialDisplayName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetMaterialDisplayName </td>
          <td>(</td>
          <td class="paramtype">AXF_MATERIAL_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMaterial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMaterial</td><td>Handle to an AxF material </td></tr>
    <tr><td class="paramname">sBuf</td><td>Character buffer big enough to hold the name of the material (or 0 to query the required buffer size only) </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sBuf in <em>bytes</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer size in bytes that is needed to return the full string (number of characters - including terminating 0 - times sizeof(wchar_t)). If iBufSize was at least this large, the full string was returned successfully, otherwise the returned string was truncated. 0 indicates an error (in which case no string is returned).</dd></dl>
<p>Returns the display name of a material as Unicode wide character string, i.e. in UTF-16 encoding on Windows or in UCS-4/UTF-32 encoding on Linux/Mac. It is recommended to query the required buffer size first (see parameter description), since the length of the display name is not limited. </p>

</div>
</div>
<a id="ae15b05d7447db96c2de30a625cf5f41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15b05d7447db96c2de30a625cf5f41f">&#9670;&nbsp;</a></span>axfGetMaterialIDString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetMaterialIDString </td>
          <td>(</td>
          <td class="paramtype">AXF_MATERIAL_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMaterial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMaterial</td><td>Handle to an AxF material </td></tr>
    <tr><td class="paramname">sBuf</td><td>Character buffer big enough to hold the ID string of the material (or 0 to query the required buffer size only) </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sBuf in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer size in bytes that is needed to return the full string (number of characters including terminating 0). If iBufSize was at least this large, the full string was returned successfully, otherwise the returned string was truncated. 0 indicates an error (in which case no string is returned).</dd></dl>
<p>In the scope of a given AxF file, the ID strings for the contained materials are unique and remain the same even if the file is edited (but not if the material is renamed). Therefore the ID string can be used as to re-indentify a certain material after closing and reopening the file (in contrast to the material handle which is invalidated when the file is closed), see <a class="el" href="namespaceaxf_1_1decoding.html#ab31e8541080b3df816b34f3e3d23eaa0" title="Get the handle to a specific material stored in the AxF file based on its ID string. ">axfFindMaterialByIDString()</a>. In contrast to the material display name (see <a class="el" href="namespaceaxf_1_1decoding.html#a7bfca744e73963e6097b27bca542a045" title="Get the display name of a given material. ">axfGetMaterialDisplayName()</a>), the ID string returned by this function should not be displayed to the user. Though if you want to display this string e.g. in debug output, you can assume ISO-8859-1 (Latin-1) encoding. Note that the length of the ID string is not limited by AXF_MAX_KEY_SIZE. </p>

</div>
</div>
<a id="a8b1222e8a1951c1829e8261f6e6a09e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1222e8a1951c1829e8261f6e6a09e4">&#9670;&nbsp;</a></span>axfGetMaterialName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetMaterialName </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iMaterial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFFile</td><td>Handle to open AxF file </td></tr>
    <tr><td class="paramname">iMaterial</td><td>Index of the material in the file (in range 0 .. <a class="el" href="namespaceaxf_1_1decoding.html#a822aebf5d5a0bd622dbda16a198b3090" title="Get the number of materials stored in the AxF file. ">axfGetNumberOfMaterials()</a>-1) </td></tr>
    <tr><td class="paramname">sBuf</td><td>Character buffer big enough to hold the ID string of the material (or 0 to query the required buffer size only) </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sBuf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer size that is needed to return the full string (number of characters including terminating 0). If iBufSize was at least this large, the full string was returned successfully, otherwise the returned string was truncated. 0 indicates an error (in which case no string is returned).</dd></dl>
<p>DEPRECATED: equivalent to axfGetMaterialIDString(axfGetMaterial(hAxFFile, iMaterial), sBuf, iBufSize)</p>
<p>Note: To query the display name of a material in order to show this in a UI, use <a class="el" href="namespaceaxf_1_1decoding.html#a7bfca744e73963e6097b27bca542a045" title="Get the display name of a given material. ">axfGetMaterialDisplayName()</a> instead. </p>

</div>
</div>
<a id="af993f697149477a50c676f35d7e98532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af993f697149477a50c676f35d7e98532">&#9670;&nbsp;</a></span>axfGetDefaultMaterialName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetDefaultMaterialName </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFFile</td><td>Handle to open AxF file </td></tr>
    <tr><td class="paramname">sBuf</td><td>Character buffer big enough to hold the ID string of the material (or 0 to query the required buffer size only) </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sBuf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer size that is needed to return the full string (number of characters including terminating 0). If iBufSize was at least this large, the full string was returned successfully, otherwise the returned string was truncated. 0 indicates an error (in which case no string is returned).</dd></dl>
<p>DEPRECATED: equivalent to axfGetMaterialIDString(axfGetDefaultMaterial(hAxFFile), sBuf, iBufSize) </p>

</div>
</div>
<a id="ab31e8541080b3df816b34f3e3d23eaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31e8541080b3df816b34f3e3d23eaa0">&#9670;&nbsp;</a></span>axfFindMaterialByIDString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_MATERIAL_HANDLE AXF_API axf::decoding::axfFindMaterialByIDString </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sMaterialID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFFile</td><td>Handle to open AxF file </td></tr>
    <tr><td class="paramname">sMaterialID</td><td>ID string of the material (cf. <a class="el" href="namespaceaxf_1_1decoding.html#ae15b05d7447db96c2de30a625cf5f41f" title="Get the ID string of a given material. ">axfGetMaterialIDString()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to found material (or zero) </dd></dl>

</div>
</div>
<a id="ac50994f4c6beda102ce4ed21b29698ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50994f4c6beda102ce4ed21b29698ed">&#9670;&nbsp;</a></span>axfGetNumberOfMetadataDocuments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetNumberOfMetadataDocuments </td>
          <td>(</td>
          <td class="paramtype">AXF_MATERIAL_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMaterial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMaterial</td><td>Handle to an AxF material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of metadata documents stored in the metadata section of the material</dd></dl>
<p>An AxF material can have more than one metadata section, i.e. <em>documents</em>, in order to support different workflows. </p>

</div>
</div>
<a id="ae6523d3b83b1964635bd4c3cf5dba644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6523d3b83b1964635bd4c3cf5dba644">&#9670;&nbsp;</a></span>axfGetNumberOfMetadataDocuments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetNumberOfMetadataDocuments </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sMaterialID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFFile</td><td>Handle to open AxF File </td></tr>
    <tr><td class="paramname">sMaterialID</td><td>ID string of the material (cf. <a class="el" href="namespaceaxf_1_1decoding.html#ae15b05d7447db96c2de30a625cf5f41f" title="Get the ID string of a given material. ">axfGetMaterialIDString()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of metadata documents stored in the metadata section of the material</dd></dl>
<p>DEPRECATED variant of the function: equivalent to axfGetNumberOfMetadataDocuments(axfFindMaterialByIDString(hAxFFile, sMaterialID)) </p>

</div>
</div>
<a id="a2de7915423992d8a88affaf07d4b1ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de7915423992d8a88affaf07d4b1ab2">&#9670;&nbsp;</a></span>axfGetMetadataDocument() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_METADATA_DOCUMENT_HANDLE AXF_API axf::decoding::axfGetMetadataDocument </td>
          <td>(</td>
          <td class="paramtype">AXF_MATERIAL_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMaterial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iMetadataDocument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMaterial</td><td>Handle to an AxF material </td></tr>
    <tr><td class="paramname">iMetadataDocument</td><td>Index of the metadata document in the material's metadata document list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to found metadata document (or zero) </dd></dl>

</div>
</div>
<a id="a8c5eeea8b6b643a290631a11b63f5620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5eeea8b6b643a290631a11b63f5620">&#9670;&nbsp;</a></span>axfGetMetadataDocument() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_METADATA_DOCUMENT_HANDLE AXF_API axf::decoding::axfGetMetadataDocument </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sMaterialID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iMetadataDocument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFFile</td><td>Handle to open AxF File </td></tr>
    <tr><td class="paramname">sMaterialID</td><td>ID string of the material (cf. <a class="el" href="namespaceaxf_1_1decoding.html#ae15b05d7447db96c2de30a625cf5f41f" title="Get the ID string of a given material. ">axfGetMaterialIDString()</a>) </td></tr>
    <tr><td class="paramname">iMetadataDocument</td><td>Index of the metadata document in the material's metadata document list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to found metadata document (or zero)</dd></dl>
<p>DEPRECATED variant of the function: equivalent to axfGetMetadataDocument(axfFindMaterialByIDString(hAxFFile, sMaterialID), iMetadataDocument) </p>

</div>
</div>
<a id="aaaf594ce212173a09924895ae7900037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf594ce212173a09924895ae7900037">&#9670;&nbsp;</a></span>axfGetMetadataDocumentName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetMetadataDocumentName </td>
          <td>(</td>
          <td class="paramtype">AXF_METADATA_DOCUMENT_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMetadataDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMetadataDocument</td><td>Handle to metadata document </td></tr>
    <tr><td class="paramname">sBuf</td><td>Character buffer big enough to hold the name (or 0 to query the required buffer size only) </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sBuf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer size that is needed to return the full string (number of characters including terminating 0). If iBufSize was at least this large, the full string was returned successfully, otherwise the returned string was truncated. 0 indicates an error (in which case no string is returned). </dd></dl>

</div>
</div>
<a id="ad01b7a220198faf6eb6b57a2bf6ad018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01b7a220198faf6eb6b57a2bf6ad018">&#9670;&nbsp;</a></span>axfGetNumberOfMetadataSubDocuments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetNumberOfMetadataSubDocuments </td>
          <td>(</td>
          <td class="paramtype">AXF_METADATA_DOCUMENT_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMetadataDocument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMetadataDocument</td><td>Handle to metadata document </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of sub- or child-metadata documents for the given metadata document</dd></dl>
<p>AxF metadata documents are recursive, i.e. they can contain sub documents. </p>

</div>
</div>
<a id="a11d133d8fa0111c068a5338695e0364e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d133d8fa0111c068a5338695e0364e">&#9670;&nbsp;</a></span>axfGetMetadataDataSubDocument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_METADATA_DOCUMENT_HANDLE AXF_API axf::decoding::axfGetMetadataDataSubDocument </td>
          <td>(</td>
          <td class="paramtype">AXF_METADATA_DOCUMENT_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMetadataDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iMetadataSubdocument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMetadataDocument</td><td>Handle to axf metadata document </td></tr>
    <tr><td class="paramname">iMetadataSubdocument</td><td>Index of the metadata subdocument in the parent's metadata document list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to found metadata document (or zero) </dd></dl>

</div>
</div>
<a id="ac9156566933190ea7cfb747141b34e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9156566933190ea7cfb747141b34e04">&#9670;&nbsp;</a></span>axfGetNumberOfMetadataProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetNumberOfMetadataProperties </td>
          <td>(</td>
          <td class="paramtype">AXF_METADATA_DOCUMENT_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMetadataDocument</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMetadataDocument</td><td>Handle to metadata document </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of properties for the given metadata document </dd></dl>

</div>
</div>
<a id="ae245435c7f8680479f49f096a77525d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae245435c7f8680479f49f096a77525d7">&#9670;&nbsp;</a></span>axfGetMetadataPropertyName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetMetadataPropertyName </td>
          <td>(</td>
          <td class="paramtype">AXF_METADATA_DOCUMENT_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMetadataDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iProperty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMetadataDocument</td><td>Handle to metadata document </td></tr>
    <tr><td class="paramname">iProperty</td><td>Index of the property </td></tr>
    <tr><td class="paramname">sBuf</td><td>Character buffer big enough to hold the name of the property (or 0 to query the required buffer size only) </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sBuf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer size that is needed to return the full string (number of characters including terminating 0). If iBufSize was at least this large, the full string was returned successfully, otherwise the returned string was truncated. 0 indicates an error (in which case no string is returned).</dd></dl>
<p>Metadata properties are classical name-value pairs inside a metadata document. </p>

</div>
</div>
<a id="a34570ac7f0b4c9692763f1a97ce996e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34570ac7f0b4c9692763f1a97ce996e6">&#9670;&nbsp;</a></span>axfGetMetadataPropertyType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetMetadataPropertyType </td>
          <td>(</td>
          <td class="paramtype">AXF_METADATA_DOCUMENT_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMetadataDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iProperty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMetadataDocument</td><td>Handle to metadata document </td></tr>
    <tr><td class="paramname">iProperty</td><td>Index of the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Datatype of the property, which may be any value of enum <a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350b" title="Enum of property data types used in the metadata retrieval interface and TextureDecoder&#39;s property in...">axf::decoding::PropertyType</a>. If the property in the AxF file has a type not supported by the current SDK version, TYPE_ERROR is returned.</dd></dl>
<p>Note: The destinction between types TYPE_STRING and TYPE_UTF_STRING for string properties stored in the AxF file exists for legacy reasons. Nonetheless, both string types can be retrieved in the same way (in UTF-16/UTF-32 encoding), see <a class="el" href="namespaceaxf_1_1decoding.html#a5b9eaf69372af5d10eb9b47ddfcb21f2" title="Returns the property value into a user provided buffer. ">axfGetMetadataPropertyValue()</a>. </p>

</div>
</div>
<a id="a37a0d87c3877056743cd10ecd94b3e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a0d87c3877056743cd10ecd94b3e7a">&#9670;&nbsp;</a></span>axfGetMetadataPropertyValueLen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetMetadataPropertyValueLen </td>
          <td>(</td>
          <td class="paramtype">AXF_METADATA_DOCUMENT_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMetadataDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iProperty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMetadataDocument</td><td>Handle to metadata document </td></tr>
    <tr><td class="paramname">iProperty</td><td>Index of the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements if the property has an array type, 1 otherwise. For TYPE_UTF_STRING the number of UTF characters <em>including</em> the terminating null character is returned. </dd></dl>

</div>
</div>
<a id="a5b9eaf69372af5d10eb9b47ddfcb21f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b9eaf69372af5d10eb9b47ddfcb21f2">&#9670;&nbsp;</a></span>axfGetMetadataPropertyValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfGetMetadataPropertyValue </td>
          <td>(</td>
          <td class="paramtype">AXF_METADATA_DOCUMENT_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMetadataDocument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iProperty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMetadataDocument</td><td>Handle to metadata document </td></tr>
    <tr><td class="paramname">iProperty</td><td>Index of the property </td></tr>
    <tr><td class="paramname">iType</td><td>The data type (from enum <a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350b" title="Enum of property data types used in the metadata retrieval interface and TextureDecoder&#39;s property in...">axf::decoding::PropertyType</a>) in which the property value should be retrieved. </td></tr>
    <tr><td class="paramname">pBuf</td><td>Pointer to memory buffer big enough to hold the property value data </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of the provided memory buffer, must be (at least) <a class="el" href="namespaceaxf_1_1decoding.html#a37a0d87c3877056743cd10ecd94b3e7a" title="Returns the length (in number of elements) of the given metadata property value. ">axfGetMetadataPropertyValueLen()</a> * sizeof(SCALAR_TYPE), with sizeof(SCALAR_TYPE)=1..4 dependent on iType (cf. documentation for enum <a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350b" title="Enum of property data types used in the metadata retrieval interface and TextureDecoder&#39;s property in...">axf::decoding::PropertyType</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em>, if data has been successfully copied</dd></dl>
<p>In general, property values should be read in the type in which they are stored in the AxF file, i.e. iType should be the type value returned by <a class="el" href="namespaceaxf_1_1decoding.html#a34570ac7f0b4c9692763f1a97ce996e6" title="Get the datatype in which a given metadata property is stored in the AxF file. ">axfGetMetadataPropertyType()</a>. Otherwise, this function tries to convert the data to the requested data type. This is supported for certain combinations of storage type and retrieval type, including:</p><ul>
<li>Bool values (TYPE_BOOLEAN) may optionally be retrieved as int values (TYPE_INT).</li>
<li>Half values (TYPE_HALF) or half arrays (TYPE_HALF_ARRAY) may optionally be retrieved as float values (TYPE_FLOAT) or float arrays (TYPE_FLOAT_ARRAY) respectively.</li>
<li>Strings stored in Latin-1 encoding (TYPE_STRING) may optionally be retrieved as strings in UTF-16 or UTF-32 encoding (TYPE_UTF_STRING), but not vice versa. Note that in this case the number of UTF-16 or UTF-32 charachters equals the number of Latin-1 characters (as returned by <a class="el" href="namespaceaxf_1_1decoding.html#a37a0d87c3877056743cd10ecd94b3e7a" title="Returns the length (in number of elements) of the given metadata property value. ">axfGetMetadataPropertyValueLen()</a>), i.e. <a class="el" href="namespaceaxf_1_1decoding.html#a37a0d87c3877056743cd10ecd94b3e7a" title="Returns the length (in number of elements) of the given metadata property value. ">axfGetMetadataPropertyValueLen()</a> * sizeof(wchar_t) is in fact the correct buffer size when retrieving TYPE_STRING properties as TYPE_UTF_STRING. </li>
</ul>

</div>
</div>
<a id="a0d456414df906f81bcc8740e9eb8a7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d456414df906f81bcc8740e9eb8a7d0">&#9670;&nbsp;</a></span>axfGetNumberOfRepresentations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetNumberOfRepresentations </td>
          <td>(</td>
          <td class="paramtype">AXF_MATERIAL_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMaterial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMaterial</td><td>Handle to an AxF material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of representations associated with the material</dd></dl>
<p>An AxF material can be represented by one or multiple representations. If a material has multiple representations, these can be considered different-quality encodings of the same material, which may differ in terms of memory consumption, rendering efficiency, etc. [Think of a document stored as pure ASCII text or as HTML containing the same text (with the same meaning) but with different annotations and detail.]</p>
<p>Each representation is associated with a version number (see <a class="el" href="namespaceaxf_1_1decoding.html#a4c61df68c3d99e01b78194f7f25c4363" title="Retrieve the representation&#39;s version number. ">axfGetRepresentationVersion()</a>), which corresponds to the lowest AxF SDK version that can decode this representation. To ensure upwards compatibility of this SDK version with AxF files generated by newer encoders, this SDK supports reading of AxF files that contain not yet supported representation versions, as long as there is at least one supported representation for some material in the file. Since all existing representations in the file can be queried via this interface, you need to make sure that you pick a representation that is actually supported by the given SDK version (see <a class="el" href="namespaceaxf_1_1decoding.html#a17f7bc70cf6d90d86eb164989e7b8c27" title="Check if representation is supported by the given SDK. ">axfIsRepresentationSupported()</a>).</p>
<p>Additionally, the capabilities of the third-party application might need to be considered (if the application implements an own renderer rather than just using the <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html" title="Decodes AxF representations on the CPU. ">CPUDecoder</a> class from this SDK for rendering). For that purpose the function <a class="el" href="namespaceaxf_1_1decoding.html#ac3229499828c83f0c934e1c865a452d3" title="Check if representation fits into the given compatibility profile. ">axfCheckRepresentationCompatibilityProfile()</a> might be used for finding a suitable representation.</p>
<p>In any case, an automatic selection of the most suitable representation should in general be preferred over a manual user selection. </p>

</div>
</div>
<a id="a8f7beeb59e7ef986a95e9fa45fb7ace3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7beeb59e7ef986a95e9fa45fb7ace3">&#9670;&nbsp;</a></span>axfGetNumberOfRepresentations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetNumberOfRepresentations </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sMaterialID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFFile</td><td>Handle to open AxF File </td></tr>
    <tr><td class="paramname">sMaterialID</td><td>ID string of the material (cf. <a class="el" href="namespaceaxf_1_1decoding.html#ae15b05d7447db96c2de30a625cf5f41f" title="Get the ID string of a given material. ">axfGetMaterialIDString()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of representations associated with the material</dd></dl>
<p>DEPRECATED variant of the function: equivalent to axfGetNumberOfRepresentations(axfFindMaterialByIDString(hAxFFile, sMaterialID)) </p>

</div>
</div>
<a id="a3c04510b187bd2d96d58d4f762e5c3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c04510b187bd2d96d58d4f762e5c3b9">&#9670;&nbsp;</a></span>axfGetRepresentation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_REPRESENTATION_HANDLE AXF_API axf::decoding::axfGetRepresentation </td>
          <td>(</td>
          <td class="paramtype">AXF_MATERIAL_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMaterial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iRepresentation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMaterial</td><td>Handle to an AxF material </td></tr>
    <tr><td class="paramname">iRepresentation</td><td>Index of the representation in the material's representation list (in range 0 .. <a class="el" href="namespaceaxf_1_1decoding.html#a822aebf5d5a0bd622dbda16a198b3090" title="Get the number of materials stored in the AxF file. ">axfGetNumberOfMaterials()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to found representation (or zero) </dd></dl>

</div>
</div>
<a id="a7b43acd4285e2196ac9aa871480afff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b43acd4285e2196ac9aa871480afff4">&#9670;&nbsp;</a></span>axfGetRepresentation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_REPRESENTATION_HANDLE AXF_API axf::decoding::axfGetRepresentation </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sMaterialID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iRepresentation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFFile</td><td>Handle to open AxF file </td></tr>
    <tr><td class="paramname">sMaterialID</td><td>ID string of the material (cf. <a class="el" href="namespaceaxf_1_1decoding.html#ae15b05d7447db96c2de30a625cf5f41f" title="Get the ID string of a given material. ">axfGetMaterialIDString()</a>). </td></tr>
    <tr><td class="paramname">iRepresentation</td><td>Index of the representation in the material's representation list (in range 0 .. <a class="el" href="namespaceaxf_1_1decoding.html#a822aebf5d5a0bd622dbda16a198b3090" title="Get the number of materials stored in the AxF file. ">axfGetNumberOfMaterials()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to found representation (or zero)</dd></dl>
<p>DEPRECATED variant of the function: equivalent to axfGetRepresentation(axfFindMaterialByIDString(hAxFFile, sMaterialID), iRepresentation) </p>

</div>
</div>
<a id="a36755ec273d115909eefb03268beec0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36755ec273d115909eefb03268beec0c">&#9670;&nbsp;</a></span>axfGetPreferredRepresentation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_REPRESENTATION_HANDLE AXF_API axf::decoding::axfGetPreferredRepresentation </td>
          <td>(</td>
          <td class="paramtype">AXF_MATERIAL_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFMaterial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFMaterial</td><td>Handle to an AxF material </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to found representation (or zero)</dd></dl>
<p>For a given material, this function tries to choose the representation that provides the best quality from all available representations that are supported by the given SDK version. This implies that the returned representation, if any, will satisfy <a class="el" href="namespaceaxf_1_1decoding.html#a17f7bc70cf6d90d86eb164989e7b8c27" title="Check if representation is supported by the given SDK. ">axfIsRepresentationSupported()</a>. (However, it might be the case that the given material has no supported representation, in which case 0 is returned.)</p>
<p>This function is primarily intended for the case that the given third-party application can actually handle <em>all</em> representations that are supported by this SDK (for instance via the use of <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html" title="Decodes AxF representations on the CPU. ">CPUDecoder</a>). If this is not the case, the application might need to explicitly enumerate the representations instead and choose the best one from those which it supports (for instance via the use of <a class="el" href="namespaceaxf_1_1decoding.html#ac3229499828c83f0c934e1c865a452d3" title="Check if representation fits into the given compatibility profile. ">axfCheckRepresentationCompatibilityProfile()</a>). </p>

</div>
</div>
<a id="a657690f1407af128ac046922b67cd020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657690f1407af128ac046922b67cd020">&#9670;&nbsp;</a></span>axfGetPreferredRepresentation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_REPRESENTATION_HANDLE AXF_API axf::decoding::axfGetPreferredRepresentation </td>
          <td>(</td>
          <td class="paramtype">AXF_FILE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sMaterialID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFFile</td><td>Handle to open AxF file </td></tr>
    <tr><td class="paramname">sMaterialID</td><td>ID string of the material (cf. <a class="el" href="namespaceaxf_1_1decoding.html#ae15b05d7447db96c2de30a625cf5f41f" title="Get the ID string of a given material. ">axfGetMaterialIDString()</a>). Optional for this function (see full text). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to found representation (or zero)</dd></dl>
<p>This variant of the function is DEPRECATED, except for the following convenience use case:</p>
<p>If no material ID string is given (i.e. if sMaterialID==0), the designated default material is chosen (see <a class="el" href="namespaceaxf_1_1decoding.html#a7c2c4753a70c7d6389791b41f5f38dd4" title="Get a handle to the default material stored in the AxF file. ">axfGetDefaultMaterial()</a>) if existing, otherwise the first material that has at least one supported representation (if existing). (This again assumes that the application can handle all representations that are supported by this SDK.) </p>

</div>
</div>
<a id="a57cd171d9aa6a6c53e0ddceb8dd06898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cd171d9aa6a6c53e0ddceb8dd06898">&#9670;&nbsp;</a></span>axfGetRepresentationClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfGetRepresentationClass </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to a representation root (as returned by <a class="el" href="namespaceaxf_1_1decoding.html#a3c04510b187bd2d96d58d4f762e5c3b9" title="Return a handle to a specific representation of an AxF material. ">axfGetRepresentation()</a> or <a class="el" href="namespaceaxf_1_1decoding.html#a36755ec273d115909eefb03268beec0c" title="Return a handle to the preferred supported representation of an AxF material. ">axfGetPreferredRepresentation()</a>) </td></tr>
    <tr><td class="paramname">sBuf</td><td>Character buffer big enough to hold the RepresentationClass string </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sBuf (AXF_MAX_KEY_SIZE is sufficient) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful</dd></dl>
<p>Classifies the given representation as one of the following categories (by considering the full hierarchical representation rooted at the given representation handle):</p><ul>
<li>AXF_REPRESENTATION_CLASS_SVBRDF ("SVBRDF"): Spatially Varying Bidirectional Reflectance Distribution Function</li>
<li>AXF_REPRESENTATION_CLASS_CARPAINT ("CarPaint"): Hybrid carpaint model (deprecated)</li>
<li>AXF_REPRESENTATION_CLASS_CARPAINT2 ("CarPaint2"): New improved carpaint model (AxF version &gt;= 1.2)</li>
<li>AXF_REPRESENTATION_CLASS_FACTORIZED_BTF ("FactorizedBTF"): Factorized Bidirectional Texture Function</li>
<li>AXF_REPRESENTATION_CLASS_LAYERED ("Layered"): A layering of multiple sub-materials </li>
</ul>

</div>
</div>
<a id="a544463086d0f705d06909be912f51ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544463086d0f705d06909be912f51ce2">&#9670;&nbsp;</a></span>axfGetRepresentationTypeKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfGetRepresentationTypeKey </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to a representation (as returned by <a class="el" href="namespaceaxf_1_1decoding.html#a3c04510b187bd2d96d58d4f762e5c3b9" title="Return a handle to a specific representation of an AxF material. ">axfGetRepresentation()</a> or <a class="el" href="namespaceaxf_1_1decoding.html#a5dbc9210d9c3801de81fb22d4cd9ed43" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the diffuse component of the BRDF model. ">axfGetSvbrdfDiffuseModelRepresentation()</a> etc.) </td></tr>
    <tr><td class="paramname">sBuf</td><td>Character buffer big enough to hold the TypeKey </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sBuf (AXF_MAX_KEY_SIZE is sufficient) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful</dd></dl>
<p>An AxF representation consists of a hierarchy of AxF nodes (describing the representation), each of which are uniquely identified by their AxF <em>TypeKey</em>. This method returns the TypeKey of the AxF node corresponding to the given representation handle. Note that a representation handle returned by <a class="el" href="namespaceaxf_1_1decoding.html#a3c04510b187bd2d96d58d4f762e5c3b9" title="Return a handle to a specific representation of an AxF material. ">axfGetRepresentation()</a> or <a class="el" href="namespaceaxf_1_1decoding.html#a36755ec273d115909eefb03268beec0c" title="Return a handle to the preferred supported representation of an AxF material. ">axfGetPreferredRepresentation()</a> corresponds to the root node of such an hierarchical representation description, while a representation handle returned by <a class="el" href="namespaceaxf_1_1decoding.html#a5dbc9210d9c3801de81fb22d4cd9ed43" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the diffuse component of the BRDF model. ">axfGetSvbrdfDiffuseModelRepresentation()</a> and <a class="el" href="namespaceaxf_1_1decoding.html#a736a18d854555b7a29eb38dade7f538c" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the specular component of the BRDF model. ">axfGetSvbrdfSpecularModelRepresentation()</a> corresponds to a sub-node in the hierarchical representation description.</p>
<p>Note that (at least since AxF version 1.1) the TypeKey of the representation's root node can in general not be used to classify the whole hierarchical representation. For that purpose, <a class="el" href="namespaceaxf_1_1decoding.html#a57cd171d9aa6a6c53e0ddceb8dd06898" title="Retrieve the RepresentationClass, which classifies the representation as SVBRDF, CarPaint, etc. ">axfGetRepresentationClass()</a> should be used instead.</p>
<p>However, dependent of the RepresentationClass returned by <a class="el" href="namespaceaxf_1_1decoding.html#a57cd171d9aa6a6c53e0ddceb8dd06898" title="Retrieve the RepresentationClass, which classifies the representation as SVBRDF, CarPaint, etc. ">axfGetRepresentationClass()</a>, the following TypeKeys can be useful to discriminate the kind of representation in more detail:</p><ul>
<li>For RepresentationClass <em>SVBRDF</em>, the TypeKey for the representation handle returned by <a class="el" href="namespaceaxf_1_1decoding.html#a5dbc9210d9c3801de81fb22d4cd9ed43" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the diffuse component of the BRDF model. ">axfGetSvbrdfDiffuseModelRepresentation()</a>:<ul>
<li>AXF_TYPEKEY_SVBRDF_DIFFUSE_LAMBERT ("com.xrite.LambertDiffuseModel")</li>
<li>AXF_TYPEKEY_SVBRDF_DIFFUSE_ORENNAYAR ("com.xrite.OrenNayarDiffuseModel")</li>
</ul>
</li>
<li>For RepresentationClass <em>SVBRDF</em>, the TypeKey for the representation handle returned by <a class="el" href="namespaceaxf_1_1decoding.html#a736a18d854555b7a29eb38dade7f538c" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the specular component of the BRDF model. ">axfGetSvbrdfSpecularModelRepresentation()</a>:<ul>
<li>AXF_TYPEKEY_SVBRDF_SPECULAR_WARD ("com.xrite.WardSpecularModel")</li>
<li>AXF_TYPEKEY_SVBRDF_SPECULAR_BLINNPHONG ("com.xrite.BlinnPhongSpecularModel")</li>
<li>AXF_TYPEKEY_SVBRDF_SPECULAR_COOKTORRANCE ("com.xrite.CookTorranceSpecularModel")</li>
<li>AXF_TYPEKEY_SVBRDF_SPECULAR_GGX ("com.xrite.GGXSpecularModel")</li>
<li>AXF_TYPEKEY_SVBRDF_SPECULAR_PHONG ("com.xrite.PhongSpecularModel") <dl class="section warning"><dt>Warning</dt><dd>inofficial</dd></dl>
</li>
</ul>
</li>
<li>For RepresentationClass <em>FactorizedBTF</em>, the TypeKey of the representation's root node:<ul>
<li>AXF_TYPEKEY_FACTORIZED_BTF_DFMF ("com.xrite.Dfmf"): Full Matrix Factorization</li>
<li>AXF_TYPEKEY_FACTORIZED_BTF_DPVF ("com.xrite.Dpvf"): Per-View Factorization</li>
</ul>
</li>
</ul>
<p>For additional information on the SVBRDF-related TypeKeys, see <a class="el" href="namespaceaxf_1_1decoding.html#a5dbc9210d9c3801de81fb22d4cd9ed43" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the diffuse component of the BRDF model. ">axfGetSvbrdfDiffuseModelRepresentation()</a> and <a class="el" href="namespaceaxf_1_1decoding.html#a736a18d854555b7a29eb38dade7f538c" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the specular component of the BRDF model. ">axfGetSvbrdfSpecularModelRepresentation()</a>. </p>

</div>
</div>
<a id="a6ab9ca074e61753d88eddcc0dd00f637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab9ca074e61753d88eddcc0dd00f637">&#9670;&nbsp;</a></span>axfGetRepresentationVariant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfGetRepresentationVariant </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sVariantStringBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to a representation </td></tr>
    <tr><td class="paramname">sVariantStringBuf</td><td>Character buffer big enough to hold the variant's identifying string </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sVariantStringBuf (AXF_MAX_KEY_SIZE is sufficient) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the representation consists of the returned variant, false if no variant is defined</dd></dl>
<p>Only the following variants of the given representations are currently part of the AxF definition:</p><ul>
<li>For RepresentationClass <em>FactorizedBTF</em> (TypeKey <em>com.xrite.Dfmf</em> or <em>com.xrite.Dpvf</em>):<ul>
<li>AXF_FACTORIZED_BTF_REPRESENTATION_VARIANT_DEFAULT (""): YUV decorrelation</li>
<li>AXF_FACTORIZED_BTF_REPRESENTATION_VARIANT_SQRTY ("SqrtY")</li>
</ul>
</li>
</ul>
<p>For additional information on AxF representations cf. <a class="el" href="index.html">AxF Decoding SDK</a>. </p>

</div>
</div>
<a id="a4c61df68c3d99e01b78194f7f25c4363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c61df68c3d99e01b78194f7f25c4363">&#9670;&nbsp;</a></span>axfGetRepresentationVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfGetRepresentationVersion </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>iMajor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>iMinor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>iRevision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to a representation </td></tr>
    <tr><td class="paramname">iMajor</td><td>Major version number </td></tr>
    <tr><td class="paramname">iMinor</td><td>Minor version number </td></tr>
    <tr><td class="paramname">iRevision</td><td>Revision number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfull</dd></dl>
<p>Returns the representation version for the given representation handle, i.e. the lowest AxF version that supports all features utilized by the given representation. </p>

</div>
</div>
<a id="a0559ae312d5a6ffa572f92d19819385c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0559ae312d5a6ffa572f92d19819385c">&#9670;&nbsp;</a></span>axfGetHighestSupportedRepresentationVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AXF_API axf::decoding::axfGetHighestSupportedRepresentationVersion </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>iMajor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>iMinor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iMajor</td><td>Major version number </td></tr>
    <tr><td class="paramname">iMinor</td><td>Minor version number</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the highest representation version supported by the given SDK (constant that corresponds to the major.minor version of the dynamic library linked against). </p>

</div>
</div>
<a id="a17f7bc70cf6d90d86eb164989e7b8c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f7bc70cf6d90d86eb164989e7b8c27">&#9670;&nbsp;</a></span>axfIsRepresentationSupported()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfIsRepresentationSupported </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to a representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the representation class is supported and the representation version does not exceed the SDK's highest supported representation version</dd></dl>
<p>The purpose of this function is to check whether the given representation is supported by given SDK version (more precisely whether a <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html" title="Decodes AxF representations on the CPU. ">CPUDecoder</a> or <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html" title="Decodes texture resources from AxF representations. ">TextureDecoder</a> can be created from it using the given SDK). This is not necessarily sufficient to determine whether the given representation is to be supported by a particular third-party application. For that, see <a class="el" href="namespaceaxf_1_1decoding.html#ac3229499828c83f0c934e1c865a452d3" title="Check if representation fits into the given compatibility profile. ">axfCheckRepresentationCompatibilityProfile()</a>.</p>
<p>This is a convenience function which is equivalent to comparing the result of <a class="el" href="namespaceaxf_1_1decoding.html#a57cd171d9aa6a6c53e0ddceb8dd06898" title="Retrieve the RepresentationClass, which classifies the representation as SVBRDF, CarPaint, etc. ">axfGetRepresentationClass()</a> against the defined representation class strings and the result of <a class="el" href="namespaceaxf_1_1decoding.html#a4c61df68c3d99e01b78194f7f25c4363" title="Retrieve the representation&#39;s version number. ">axfGetRepresentationVersion()</a> against <a class="el" href="namespaceaxf_1_1decoding.html#a0559ae312d5a6ffa572f92d19819385c" title="Retrieve the SDK&#39;s highest supported representation version. ">axfGetHighestSupportedRepresentationVersion()</a>. </p>

</div>
</div>
<a id="ac3229499828c83f0c934e1c865a452d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3229499828c83f0c934e1c865a452d3">&#9670;&nbsp;</a></span>axfCheckRepresentationCompatibilityProfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfCheckRepresentationCompatibilityProfile </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sCompatibilityProfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to a representation </td></tr>
    <tr><td class="paramname">sCompatibilityProfile</td><td>The compatibility profile string </td></tr>
    <tr><td class="paramname">iVersion</td><td>Version of the given compatibility profile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if representation matches the given compatibility profile</dd></dl>
<p>A representation matches a certain compatibility profile if it uses a certain subset of features only (besides having a supported representation version). This is intended for ensuring compatibility to third-party renderers (or other third-party applications). The basic idea is that at file creation, the user may enforce that representations for a certain compatibility profile will be included in the AxF file. If the third-party application is known to support all features of that compatibility profile, it is assured that it will be able to pick a representation that it can handle. For this use case, an application can enumerate all representations, while making corresponding calls to this function to see which representations match the application's supported profile(s).</p>
<p>The following compatibility profiles (specified by profile string and profile version) are defined:</p>
<p>Profile strings:</p><ul>
<li>AXF_COMPAT_PROF_SVBRDF ("AxFSvbrdf")</li>
<li>AXF_COMPAT_PROF_SVBRDF_REFRACT ("AxFSvbrdfRefract")</li>
<li>AXF_COMPAT_PROF_CARPAINT ("AxFCarPaint")</li>
<li>AXF_COMPAT_PROF_CARPAINT_REFRACT ("AxFCarPaintRefract")</li>
<li>AXF_COMPAT_PROF_BTF ("AxFBtf")</li>
<li>AXF_COMPAT_PROF_BASELINE_SVBRDF ("AxFBaselineFixedSvbrdf") - <em>deprecated</em></li>
<li>AXF_COMPAT_PROF_BASELINE_BTF ("AxFBaselineFixedBtf") - <em>deprecated</em></li>
</ul>
<p>The following table lists the representation classes, variants, and features for each defined profile. (The deprecated profiles shouldn't be used in new code and are thus omitted from the table.)</p>
<table class="doxtable">
<tr>
<th rowspan="4"><br />
<br />
Profile<br />
string<br />
 </th><th rowspan="4"><br />
<br />
Profile<br />
version </th><th colspan="14">SVBRDF </th><th colspan="4">FactorizedBTF </th><th colspan="4">CarPaint2  </th></tr>
<tr>
<td colspan="2" align="center">Diffuse Model </td><td colspan="8" align="center">Specular Model </td><td rowspan="1" colspan="2" align="center">Clearcoat Layer </td><td rowspan="1" colspan="2" align="center">Auxiliary Maps </td><td rowspan="2" colspan="2" align="center">com.xrite.Dfmf </td><td rowspan="2" colspan="2" align="center">com.xrite.Dpvf </td><td rowspan="2" colspan="2"></td><td rowspan="1" colspan="2" align="center">Clearcoat Layer  </td></tr>
<tr>
<td rowspan="2">Lambert </td><td rowspan="2">Oren-<br />
Nayar </td><td colspan="3" align="center">Ward (Iso-/Anisotropic) </td><td colspan="2" align="center">Blinn-Phong (Iso-/Anisotropic) </td><td rowspan="2">Cook-<br />
Torrance </td><td rowspan="2">GGX </td><td rowspan="2" align="center">Fresnel Term<br />
(Schlick1994) </td><td rowspan="1" colspan="2" align="center">Refraction </td><td rowspan="2" align="center">Alpha<br />
(Opacity) </td><td rowspan="2" align="center">Height<br />
(Displacement) </td><td rowspan="1" colspan="2" align="center">Refraction  </td></tr>
<tr>
<td>GM2010 </td><td>Duer2006 </td><td>Ward1992 </td><td>Ashikhmin2000 </td><td>Blinn1977 </td><td>Yes </td><td>No </td><td>Yuv (Default) </td><td>SqrtY </td><td>Yuv (Default) </td><td>SqrtY </td><td>Brdf </td><td>Flakes </td><td>Yes </td><td>No  </td></tr>
<tr>
<td>AxFSvbrdf </td><td>1 </td><td>x </td><td></td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td>x </td><td></td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>AxFSvbrdf </td><td>2 </td><td>x </td><td></td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td>x </td><td></td><td>x </td><td>x </td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>AxFSvbrdf </td><td>3 </td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>x </td><td>x </td><td></td><td>x </td><td>x </td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>AxFSvbrdfRefract </td><td>1 </td><td>x </td><td></td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td>x </td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>AxFSvbrdfRefract </td><td>2 </td><td>x </td><td></td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td>x </td><td>x </td><td></td><td>x </td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>AxFSvbrdfRefract </td><td>3 </td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>x </td><td>x </td><td>x </td><td></td><td>x </td><td>x </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>AxFCarPaint </td><td>1 </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>x </td><td>x* </td><td></td><td>x  </td></tr>
<tr>
<td>AxFCarPaintRefract </td><td>1 </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>x </td><td>x* </td><td>x </td><td></td></tr>
<tr>
<td>AxFBtf </td><td>1 </td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>x </td><td>x </td><td>x </td><td>x </td><td></td><td></td><td></td><td></td></tr>
</table>
<p>(*) Flakes are an optional feature for third-party renderers: an application does not need to render them to be compliant with the profile.</p>
<p>Compatibility profiles are always inclusive which means all features of a matching representation must be part of the profile but not all features of the profile need to be present in the representation.</p>
<p>Note that for SVBRDF and car paint, there are two profiles each, which match only representations with refractive or non-refractive clear coat layer respectively, for the case that an application supports only one of these two clear coat variants. (Otherwise the application should check for both of these profile variants.) Representations that do not include a clear coat layer implicitly match both of these profile variants.</p>
<p>Further note that only <em>CarPaint2</em> representations match the profiles AXF_COMPAT_PROF_CARPAINT and AXF_COMPAT_PROF_CARPAINT_REFRACT, not representations for the old, deprecated <em>CarPaint</em> representation class (see <a class="el" href="page2.html#carpaint_sec02">Hybrid Carpaint Model in AxF ("CarPaint") - deprecated</a>).</p>
<p>If this function returns true, this also implies <a class="el" href="namespaceaxf_1_1decoding.html#a17f7bc70cf6d90d86eb164989e7b8c27" title="Check if representation is supported by the given SDK. ">axfIsRepresentationSupported()</a>.</p>
<p>If the selected representation is not compatible to the application's supported compatibility profile an appropriate message like </p><pre class="fragment">No AxF representation compatible with &lt;YourApplication&gt; has been found in the AxF file &lt;FileName&gt;
</pre><p>should be presented to the user. </p>

</div>
</div>
<a id="a5a7dcab437aaed39f39005fb303f7ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a7dcab437aaed39f39005fb303f7ddc">&#9670;&nbsp;</a></span>axfGetCarPaintFlakesBtfRepresentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_REPRESENTATION_HANDLE AXF_API axf::decoding::axfGetCarPaintFlakesBtfRepresentation </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFCarPaintRepresentation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFCarPaintRepresentation</td><td>Valid handle to an AxF representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the flakes BTF child representation if existing, 0 otherwise (Note that flakes are an optional component for CarPaint / CarPaint2 representations.) </dd></dl>

</div>
</div>
<a id="ac89bfa6d36f34e0d4ab14a89a5c96943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89bfa6d36f34e0d4ab14a89a5c96943">&#9670;&nbsp;</a></span>axfGetCarPaintTabulatedBrdfRepresentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_REPRESENTATION_HANDLE AXF_API axf::decoding::axfGetCarPaintTabulatedBrdfRepresentation </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFCarPaintRepresentation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFCarPaintRepresentation</td><td>Valid handle to an AxF representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the tabulated BRDF child representation if existing, 0 otherwise </dd></dl>

</div>
</div>
<a id="a5dbc9210d9c3801de81fb22d4cd9ed43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbc9210d9c3801de81fb22d4cd9ed43">&#9670;&nbsp;</a></span>axfGetSvbrdfDiffuseModelRepresentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_REPRESENTATION_HANDLE AXF_API axf::decoding::axfGetSvbrdfDiffuseModelRepresentation </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFSvbrdfRepresentation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFSvbrdfRepresentation</td><td>Valid handle to an AxF representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the diffuse model child representation if existing, 0 otherwise</dd></dl>
<p>The SVBRDF representation as implemented within AxF supports different models for the diffuse component. The following representation TypeKeys are part of the current AxF definition and supported by the AxF SDK (cf. <a class="el" href="namespaceaxf_1_1decoding.html#a544463086d0f705d06909be912f51ce2" title="Retrieve the TypeKey from the given representation node. ">axfGetRepresentationTypeKey()</a>):</p><ul>
<li><em>com.xrite.LambertDiffuseModel</em>: classic Lambertian diffuse model</li>
<li><em>com.xrite.OrenNayarDiffuseModel</em>: not implemented yet</li>
</ul>
<p>More details can be found at <a class="el" href="page1.html">SVBRDF Representation</a>. </p>

</div>
</div>
<a id="a736a18d854555b7a29eb38dade7f538c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736a18d854555b7a29eb38dade7f538c">&#9670;&nbsp;</a></span>axfGetSvbrdfSpecularModelRepresentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_REPRESENTATION_HANDLE AXF_API axf::decoding::axfGetSvbrdfSpecularModelRepresentation </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFSvbrdfRepresentation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFSvbrdfRepresentation</td><td>Valid handle to an AxF representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to the specular model child representation if existing, 0 otherwise</dd></dl>
<p>The SVBRDF representation as implemented within AxF supports different models for the specular component. The following representation TypeKeys are part of the current AxF definition and supported by the AxF SDK (cf. <a class="el" href="namespaceaxf_1_1decoding.html#a544463086d0f705d06909be912f51ce2" title="Retrieve the TypeKey from the given representation node. ">axfGetRepresentationTypeKey()</a>):</p><ul>
<li><em>com.xrite.WardSpecularModel</em>: Ward model</li>
<li><em>com.xrite.BlinnPhongSpecularModel</em>: Blinn-Phong model (classic isotropic version as well as anisotropic version as proposed by Ashikhmin-Shirley)</li>
<li><em>com.xrite.CookTorranceSpecularModel</em>: Cook-Torrance model</li>
<li><em>com.xrite.PhongSpecularModel</em>: classic Phong model <dl class="section warning"><dt>Warning</dt><dd>inofficial</dd></dl>
More details can be found at <a class="el" href="page1.html">SVBRDF Representation</a>. </li>
</ul>

</div>
</div>
<a id="a9260fc8b8fba5f1cc449f9557ed4e199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9260fc8b8fba5f1cc449f9557ed4e199">&#9670;&nbsp;</a></span>axfGetSvbrdfSpecularModelVariant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfGetSvbrdfSpecularModelVariant </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFSpecularModelRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sVariantStringBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>bIsAnisotropic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>bHasFresnel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFSpecularModelRepresentation</td><td>Valid handle to an AxF specular model representation (cf. <a class="el" href="namespaceaxf_1_1decoding.html#a736a18d854555b7a29eb38dade7f538c" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the specular component of the BRDF model. ">axfGetSvbrdfSpecularModelRepresentation()</a>) </td></tr>
    <tr><td class="paramname">sVariantStringBuf</td><td>Character buffer big enough to hold the variant's identifying string </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sVariantStringBuf (AXF_MAX_KEY_SIZE is sufficient) </td></tr>
    <tr><td class="paramname">bIsAnisotropic</td><td>Is it the anisotropic variant of the model? </td></tr>
    <tr><td class="paramname">bHasFresnel</td><td>Does the model include a Fresnel term? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if successful.</dd></dl>
<p>The following variants are currently part of the AxF definition:</p><ul>
<li><em>com.xrite.WardSpecularModel</em><ul>
<li>AXF_SVBRDF_SPECULAR_WARD_VARIANT_GEISLERMORODER ("GeislerMoroder2010")</li>
<li>AXF_SVBRDF_SPECULAR_WARD_VARIANT_DUER ("Duer2006")</li>
<li>AXF_SVBRDF_SPECULAR_WARD_VARIANT_WARD ("Ward1992")</li>
</ul>
</li>
<li><em>com.xrite.BlinnPhongSpecularModel</em><ul>
<li>AXF_SVBRDF_SPECULAR_BLINN_VARIANT_ASHIKHMIN_SHIRLEY ("Ashikhmin2000")</li>
<li>AXF_SVBRDF_SPECULAR_BLINN_VARIANT_BLINN ("Blinn1977")</li>
<li>AXF_SVBRDF_SPECULAR_BLINN_VARIANT_VRAY ("VRay") <dl class="section warning"><dt>Warning</dt><dd>inoffical</dd></dl>
</li>
<li>AXF_SVBRDF_SPECULAR_BLINN_VARIANT_LEWIS ("Lewis1993") <dl class="section warning"><dt>Warning</dt><dd>inoffical</dd></dl>
</li>
</ul>
</li>
<li><em>com.xrite.CookTorranceSpecularModel</em><ul>
<li>no variants defined yet</li>
</ul>
</li>
<li><em>com.xrite.GGXSpecularModel</em><ul>
<li>no variants defined yet </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a25dc1b612b112141e79a835e93b56697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dc1b612b112141e79a835e93b56697">&#9670;&nbsp;</a></span>axfGetSvbrdfSpecularFresnelVariant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfGetSvbrdfSpecularFresnelVariant </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFSpecularModelRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sVariantStringBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFSpecularModelRepresentation</td><td>Valid handle to an AxF specular model representation (cf. <a class="el" href="namespaceaxf_1_1decoding.html#a736a18d854555b7a29eb38dade7f538c" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the specular component of the BRDF model. ">axfGetSvbrdfSpecularModelRepresentation()</a>) that has a Fresnel term (cf. <a class="el" href="namespaceaxf_1_1decoding.html#a9260fc8b8fba5f1cc449f9557ed4e199" title="Retrieve a string and a few flags identifying the variant of the specular model represented in the Ax...">axfGetSvbrdfSpecularModelVariant()</a>) </td></tr>
    <tr><td class="paramname">sVariantStringBuf</td><td>Character buffer big enough to hold the variant's identifying string </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sVariantStringBuf (AXF_MAX_KEY_SIZE is sufficient) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if successful.</dd></dl>
<p>The following variants are currently part of the AxF definition:</p><ul>
<li>AXF_SVBRDF_FRESNEL_VARIANT_SCHLICK ("Schlick1994")</li>
<li>AXF_SVBRDF_FRESNEL_VARIANT_FRESNEL ("Fresnel1818") <dl class="section warning"><dt>Warning</dt><dd>inoffical </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a304496f0d45dba2d7ce426580f97aa3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304496f0d45dba2d7ce426580f97aa3d">&#9670;&nbsp;</a></span>axfGetNumberOfRepresentationResources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetNumberOfRepresentationResources </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of unique resources referenced by the representation </dd></dl>

</div>
</div>
<a id="a6a5f1c0e4db091044fdedeb2fe31c128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5f1c0e4db091044fdedeb2fe31c128">&#9670;&nbsp;</a></span>axfGetRepresentationResourceFromIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_RESOURCE_HANDLE AXF_API axf::decoding::axfGetRepresentationResourceFromIndex </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iResource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to representation </td></tr>
    <tr><td class="paramname">iResource</td><td>index of resource within representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to AxF resource</dd></dl>
<p>This can be used to enumerate all resources that are referenced by a representation (or its sub-representations). </p>

</div>
</div>
<a id="ac5b624485b1c35882434f279a03c83db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b624485b1c35882434f279a03c83db">&#9670;&nbsp;</a></span>axfGetRepresentationResourceFromLookupPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_RESOURCE_HANDLE AXF_API axf::decoding::axfGetRepresentationResourceFromLookupPath </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sLookupPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to representation </td></tr>
    <tr><td class="paramname">sLookupPath</td><td>Lookup path (cf. <a class="el" href="namespaceaxf_1_1decoding.html#a119f5814787f0ac52d8060f5b6b24d35" title="Retrieve a resource&#39;s &quot;lookup path&quot;. ">axfGetResourceLookupPath()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to AxF resource</dd></dl>
<p>Given a representation and a lookup operator - specified by a "lookup path" -, return the resource that this lookup operator references. (The "lookup path" corresponds to the AxF node path of the respective lookup operator node relative to the representation node, optionally followed by "[index]" for array-like lookup operators that reference multiple resources.) </p>

</div>
</div>
<a id="adada11879d18bd23c358aa97d50816b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adada11879d18bd23c358aa97d50816b0">&#9670;&nbsp;</a></span>axfGetRepresentationResourceFromLookupName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AXF_RESOURCE_HANDLE AXF_API axf::decoding::axfGetRepresentationResourceFromLookupName </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sLookupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSearchRecursive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to representation </td></tr>
    <tr><td class="paramname">sLookupName</td><td>Lookup name (last component of the lookup path) </td></tr>
    <tr><td class="paramname">bSearchRecursive</td><td>If true all representation's child nodes are searched for a lookup of the given name. Please note that the first matching node is returned in this case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>handle to AxF resource</dd></dl>
<p>Given a representation and a lookup operator - specified by a "lookup name" -, return the resource that this lookup operator references. The "lookup name" corresponds to the last component of the "lookup path" (cf. <a class="el" href="namespaceaxf_1_1decoding.html#ac5b624485b1c35882434f279a03c83db" title="Return handle to a representation&#39;s resource from a &quot;lookup path&quot;. ">axfGetRepresentationResourceFromLookupPath()</a>).</p>
<p>With bSearchRecursive = false, this is equivalent to calling <a class="el" href="namespaceaxf_1_1decoding.html#ac5b624485b1c35882434f279a03c83db" title="Return handle to a representation&#39;s resource from a &quot;lookup path&quot;. ">axfGetRepresentationResourceFromLookupPath()</a> with lookup path "com.xrite.Resources/&lt;lookup name&gt;". With bSearchRecursive = true, this is equivalent to enumerating all resources referenced by the representation or its sub-representations (cf. <a class="el" href="namespaceaxf_1_1decoding.html#a6a5f1c0e4db091044fdedeb2fe31c128" title="Return handle to a representation&#39;s resource by index. ">axfGetRepresentationResourceFromIndex()</a>) and returning the first one whose lookup path ends in ".../&lt;lookup name&gt;" (cf. <a class="el" href="namespaceaxf_1_1decoding.html#a119f5814787f0ac52d8060f5b6b24d35" title="Retrieve a resource&#39;s &quot;lookup path&quot;. ">axfGetResourceLookupPath()</a>). </p>

</div>
</div>
<a id="a119f5814787f0ac52d8060f5b6b24d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119f5814787f0ac52d8060f5b6b24d35">&#9670;&nbsp;</a></span>axfGetResourceLookupPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetResourceLookupPath </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AXF_RESOURCE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to representation </td></tr>
    <tr><td class="paramname">hAxFResource</td><td>Valid handle to resource </td></tr>
    <tr><td class="paramname">sBuf</td><td>Character buffer big enough to hold the path (or 0 to query the required buffer size only) </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sBuf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer size that is needed to return the full string (number of characters including terminating 0). If iBufSize was at least this large, the full string was returned successfully, otherwise the returned string was truncated. 0 indicates an error (in which case no string is returned).</dd></dl>
<p>The "lookup path" of a resource with respect to a given representation specifies the <em>semantic</em> of the respective resource for that representation, i.e. which model parameter of the given representation it represents.</p>
<p>See <a class="el" href="namespaceaxf_1_1decoding.html#ac5b624485b1c35882434f279a03c83db" title="Return handle to a representation&#39;s resource from a &quot;lookup path&quot;. ">axfGetRepresentationResourceFromLookupPath()</a> for more details on the "lookup path". In particular, note that the path is relative to the given representation.</p>
<p>If neither the given representation nor its sub-representations reference the given resource, 0 is returned. </p>

</div>
</div>
<a id="ae646a651409d5522692c6679bd1a837a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae646a651409d5522692c6679bd1a837a">&#9670;&nbsp;</a></span>axfGetResourceNodePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetResourceNodePath </td>
          <td>(</td>
          <td class="paramtype">AXF_RESOURCE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFResource</td><td>Valid handle to resource </td></tr>
    <tr><td class="paramname">sBuf</td><td>Character buffer big enough to hold the path (or 0 to query the required buffer size only) </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of sBuf </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buffer size that is needed to return the full string (number of characters including terminating 0). If iBufSize was at least this large, the full string was returned successfully, otherwise the returned string was truncated. 0 indicates an error (in which case no string is returned).</dd></dl>
<p>The resource's node path is defined by recursively concatenating the node names of the resource parent nodes in the AxF file until the material resource collection node is reached.</p>
<p>Note that the node path is not fixed as per AxF specification, thus in general it is not suited for intentifying the semantic of a resource (with respect to a representation). For that purpose, <a class="el" href="namespaceaxf_1_1decoding.html#a119f5814787f0ac52d8060f5b6b24d35" title="Retrieve a resource&#39;s &quot;lookup path&quot;. ">axfGetResourceLookupPath()</a> should be used instead.</p>
<p>This function is mainly useful for diagnostic purposes. </p>

</div>
</div>
<a id="ad10db6a8b43694d187367c0747fe6b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad10db6a8b43694d187367c0747fe6b67">&#9670;&nbsp;</a></span>axfGetResourceDataNumDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetResourceDataNumDims </td>
          <td>(</td>
          <td class="paramtype">AXF_RESOURCE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFResource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFResource</td><td>Valid handle to resource </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of dimensions of resource data</dd></dl>
<p>Typical instances of resource data are either uniforms (1 dimension) or textures (&gt; 1 dimensions). Note that this refers to the actual dimension of the multi-dimensional data array and is different from what is commonly considered the dimension of a texture. For instance, a "2D" texture parameterized by UV typically has 3 dimensions: V, U, and channel (where V is the outermost dimension when enrolled into in a C array as per <a class="el" href="namespaceaxf_1_1decoding.html#a9ce0753fab1074e5e534850aa0cf1bdd" title="Copy the resource data into the provided buffer. ">axfGetResourceData()</a>). </p>

</div>
</div>
<a id="a11de2ff8af762b47ef90c0085e32d967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11de2ff8af762b47ef90c0085e32d967">&#9670;&nbsp;</a></span>axfGetResourceDataDimExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetResourceDataDimExtent </td>
          <td>(</td>
          <td class="paramtype">AXF_RESOURCE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFResource</td><td>Valid handle to resource </td></tr>
    <tr><td class="paramname">iDim</td><td>the dimension's index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Extent of dimension </dd></dl>

</div>
</div>
<a id="a6121c70ddeb1237aeb24656c735e9374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6121c70ddeb1237aeb24656c735e9374">&#9670;&nbsp;</a></span>axfGetResourceDataNumElems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetResourceDataNumElems </td>
          <td>(</td>
          <td class="paramtype">AXF_RESOURCE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFResource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFResource</td><td>Valid handle to resource </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of elements in the resource </dd></dl>

</div>
</div>
<a id="a9ce0753fab1074e5e534850aa0cf1bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce0753fab1074e5e534850aa0cf1bdd">&#9670;&nbsp;</a></span>axfGetResourceData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AXF_API axf::decoding::axfGetResourceData </td>
          <td>(</td>
          <td class="paramtype">AXF_RESOURCE_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFResource</td><td>Valid handle to resource </td></tr>
    <tr><td class="paramname">pfBuffer</td><td>float buffer big enough to hold the resource data </td></tr>
    <tr><td class="paramname">iBufSize</td><td>size of the given float buffer, must be (at least) <a class="el" href="namespaceaxf_1_1decoding.html#a6121c70ddeb1237aeb24656c735e9374" title="Retrieve the total number of elements in the resource i.e. the enrolled extensions along each dimensi...">axfGetResourceDataNumElems()</a> * sizeof(float)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of elements in the resource on success (same as <a class="el" href="namespaceaxf_1_1decoding.html#a6121c70ddeb1237aeb24656c735e9374" title="Retrieve the total number of elements in the resource i.e. the enrolled extensions along each dimensi...">axfGetResourceDataNumElems()</a>), 0 on failure </dd></dl>

</div>
</div>
<a id="a24e437bf6aef5dbeae136a266f30f365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e437bf6aef5dbeae136a266f30f365">&#9670;&nbsp;</a></span>axfGetPreviewImageInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfGetPreviewImageInfo </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iImageIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>iWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>iHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>iChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>fWidthMM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>fHeightMM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to a representation </td></tr>
    <tr><td class="paramname">iImageIdx</td><td>Index of the preview image to query (in range 0 .. axfGetNumPreviewImages()-1) </td></tr>
    <tr><td class="paramname">iWidth</td><td>Width of the stored preview image in pixels (output parameter) </td></tr>
    <tr><td class="paramname">iHeight</td><td>Height of the stored preview image in pixels (output parameter) </td></tr>
    <tr><td class="paramname">iChannels</td><td>Will be set to 4 if the stored preview image contains an alpha/opacity channel, 3 otherwise (output parameter) </td></tr>
    <tr><td class="paramname">fWidthMM</td><td>Spatial width of the stored preview image in millimeters (output parameter) </td></tr>
    <tr><td class="paramname">fHeightMM</td><td>Spatial height of the stored preview image in millimeters (output parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful</dd></dl>
<p>Note that the output value iChannel is provided for convenient usage of <a class="el" href="namespaceaxf_1_1decoding.html#ae251ba22615aab7acd58f0240b660257" title="Returns a representation preview image into a user provided buffer. ">axfGetPreviewImage()</a> only, see its description. iChannel does not necessarily coincide with the original number of channels of the stored preview image (in case it is stored in a non-trichromatic source color space), since the original number of channels is not relevant for usage of <a class="el" href="namespaceaxf_1_1decoding.html#ae251ba22615aab7acd58f0240b660257" title="Returns a representation preview image into a user provided buffer. ">axfGetPreviewImage()</a>. Instead, iChannels can be used safely to distinguish whether the stored preview image contains an alpha/opacity channel (in which case it will be set to 4) or not (in which case it will be set to 3). </p>

</div>
</div>
<a id="ae251ba22615aab7acd58f0240b660257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae251ba22615aab7acd58f0240b660257">&#9670;&nbsp;</a></span>axfGetPreviewImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfGetPreviewImage </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iImageIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sTargetColorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iTextureOrigin</em> = <code><a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546af81cf674c1146c260fd907f0794d252b">ORIGIN_BOTTOMLEFT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to a representation </td></tr>
    <tr><td class="paramname">iImageIdx</td><td>Index of the preview image to query (in range 0 .. axfGetNumPreviewImages()-1) </td></tr>
    <tr><td class="paramname">sTargetColorSpace</td><td>Trichromatic target color space (see below) </td></tr>
    <tr><td class="paramname">pImage</td><td>pointer to a buffer of iWidth*iHeight*iChannels floats, in which to retrieve the preview image </td></tr>
    <tr><td class="paramname">iWidth</td><td>width of the preview image in pixels </td></tr>
    <tr><td class="paramname">iHeight</td><td>height of the preview image in pixels </td></tr>
    <tr><td class="paramname">iChannels</td><td>number of channels of the image buffer (3 or 4) </td></tr>
    <tr><td class="paramname">iTextureOrigin</td><td>cf. enum ETextureOrigin</td></tr>
  </table>
  </dd>
</dl>
<p>iWidth and iHeight must match the corresponding values returned by <a class="el" href="namespaceaxf_1_1decoding.html#a24e437bf6aef5dbeae136a266f30f365" title="Retrieve information about a representation preview image. ">axfGetPreviewImageInfo()</a>. If you want to retrieve an alpha/opacity channel if and only if the stored preview image contains one, also choose iChannel to match the value returned by <a class="el" href="namespaceaxf_1_1decoding.html#a24e437bf6aef5dbeae136a266f30f365" title="Retrieve information about a representation preview image. ">axfGetPreviewImageInfo()</a>. Otherwise you may choose iChannel differently (see below).</p>
<p>sTargetColorSpace must be one of:</p><ul>
<li>AXF_COLORSPACE_CIE_1931_XYZ ("XYZ"): the CIE 1931 XYZ color space</li>
<li>AXF_COLORSPACE_LINEAR_SRGB_E ("sRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the sRGB color space (IEC 61966-2-1), but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
<li>AXF_COLORSPACE_LINEAR_ADOBE_RGB_E ("AdobeRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the Adobe RGB (1988) color space, but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
<li>AXF_COLORSPACE_LINEAR_ADOBE_WIDEGAMUT_RGB_E ("WideGamutRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the Adobe Wide-Gamut RGB color space, but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
<li>AXF_COLORSPACE_LINEAR_PROPHOTO_RGB_E ("ProPhotoRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the ProPhoto RGB color space, but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
</ul>
<p>The preview image from the AxF file is transformed to the specified target color space. Currently only trichromatic target color spaces are supported (irrespective of whether the image is stored in a trichromatic color space in the AxF file or not).</p>
<p>Thus iChannels must be either 3 or 4:</p><ul>
<li>For iChannels = 3, a 3-channel color image (without alpha) is returned. If the source preview image from the AxF file actually has an alpha/opacity channel, the SDK tries to convert it to a non-transparent preview image by rendering it in front of a checkerboard background, which becomes "baked" into the resulting 3-channel image. Note that the latter is only guarantueed to work correctly for the default planar preview image (named AXF_PREVIEW_IMAGE_NAME_DEFAULT).</li>
<li>For iChannels = 4, a 4-channel color/alpha image is returned (e.g. RGBA). No background is integrated into the resulting image. If the source preview image from the AxF file does not have an alpha/opacity channel, a trivial alpha channel (1.0f) is added to the result image. </li>
</ul>

</div>
</div>
<a id="a09fd2908f12def53a464dcf61f17cef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fd2908f12def53a464dcf61f17cef8">&#9670;&nbsp;</a></span>axfGetSpectralizationTrafo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AXF_API axf::decoding::axfGetSpectralizationTrafo </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>vSpectralSampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iNumSpectralSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sSourceColorSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to a representation </td></tr>
    <tr><td class="paramname">vSpectralSampling</td><td>Array of float values containing the spectral sample points in nm </td></tr>
    <tr><td class="paramname">iNumSpectralSamples</td><td>Number of spectral samples (number of elements in vSpectralSampling) </td></tr>
    <tr><td class="paramname">pMatrix</td><td>iNumSpectralSamplesx3 sized float buffer for holding the linear color transformation in row (column-) major order. </td></tr>
    <tr><td class="paramname">sSourceColorSpace</td><td>The color space to be used as source of the transformation in "Colspace,WP" notation (see <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#acb81a71521ab469e5c85b4e81c07f7f6" title="Create a texture decoder for a given AxF representation, target color space and target system ID...">CPUDecoder::create()</a> or <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a135b6c876ace1227a8e7dacac70ed09b" title="Create a texture decoder for a given AxF representation, target color space and target system ID...">TextureDecoder::create()</a>). Typically, the target color space of the respective decoder (<a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html" title="Decodes AxF representations on the CPU. ">CPUDecoder</a> or <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html" title="Decodes texture resources from AxF representations. ">TextureDecoder</a>) is to be used here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if successful.</dd></dl>
<p>This function returns a "spectralization" transformation which transform from the representation's source color space or a user defined color space to a given spectral sampling. The second option can be used e.g. if the application wants to transform the color value from the representations's source color space into another trichromatic working color space first This spectralization transformation has been optimized for the materials spectral properties and significantly improves upon a standard RGB-to-spectral conversion (e.g. <a class="el" href="citelist.html#CITEREF_Smits99">[9]</a>)). </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 18 2018 00:04:38 for AxF Decoding SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
