<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AxF Decoding SDK: Hybrid Model- and Image-based Carpaint Representation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="AxF-SDK-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AxF Decoding SDK
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">Decoding AxF representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">AxF Decoding SDK</a></li><li class="navelem"><a class="el" href="pages1-3.html">AxF Representations</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Hybrid Model- and Image-based Carpaint Representation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#carpaint_sec01">Preliminaries</a></li>
<li class="level1"><a href="#carpaint_sec02">Hybrid Carpaint Model in AxF (&quot;CarPaint&quot;) - deprecated</a></li>
<li class="level1"><a href="#carpaint_sec03">Improved Hybrid Carpaint Model in AxF (&quot;CarPaint2&quot;)</a><ul><li class="level2"><a href="#carpaint_BrightnessBRDF">Brightness BRDF</a></li>
<li class="level2"><a href="#carpaint_ColorTable">Color Table</a></li>
<li class="level2"><a href="#carpaint_FlakeBTF">Flake BTF Textures</a></li>
<li class="level2"><a href="#carpaint_combined">Combined model</a></li>
<li class="level2"><a href="#carpaint_Summary">Summary</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="carpaint_sec01"></a>
Preliminaries</h1>
<p><br />
 AxF supports the hybrid carpaint model as proposed by Rump et al. in the following publications</p><ul>
<li><em>Photo-realistic rendering of metallic car paint from image-based measurements</em> <a class="el" href="citelist.html#CITEREF_rump-2008-photo-realistic">[5]</a></li>
<li><em>Efficient resampling, compression and rendering of metallic and pearlescent paint</em> <a class="el" href="citelist.html#CITEREF_rump-vmv-09">[6]</a></li>
</ul>
<p>The unique feature of this model is that it uses a parametric BRDF for the homogeneous part of the paint and an image-based model based on patches extracted from a BTF measurement for the spatially varying part i.e. the flakes.</p>
<div class="image">
<img src="hybrid_carpaint.png" alt="hybrid_carpaint.png"/>
<div class="caption">
Rendering a measured carpaint with two different illuminations using the hybrid model</div></div>
<h1><a class="anchor" id="carpaint_sec02"></a>
Hybrid Carpaint Model in AxF ("CarPaint") - deprecated</h1>
<p>The model is supported for legacy reasons only and shouldn't be integrated into new third-party applications anymore. A new carpaint model is supported by AxF/SDK version 1.2 (see below).</p>
<p>AxF representation class: <em>CarPaint</em></p>
<p>AxF representation version: 1.0.0</p>
<p>Names of the textures that can be queried via <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html" title="Decodes texture resources from AxF representations. ">axf::decoding::TextureDecoder</a>:</p><ul>
<li>BRDFcolors</li>
<li>BTFpatches</li>
<li>BTFsynth</li>
<li>BTFLightIndicesAndWeights</li>
</ul>
<h1><a class="anchor" id="carpaint_sec03"></a>
Improved Hybrid Carpaint Model in AxF ("CarPaint2")</h1>
<p>In practice the first version of the hybrid carpaint model exhibited some serious deficiencies in the reproduction of colorshift and visual appearance of flakes for some materials and especially for measurements using desktop class devices like the TAC7. These deficiencies could mainly be attributed to sparse sampling of the 3D (isotropic) angular direction space. As a result the second version of the carpaint representation has been developed. It shares the same BRDF model for the brightness variation with the first version, a multi-lobe variant of the Cook-Torrance model, but introduces novel techniques for color variation and flake representation.</p>
<p>Find below a comparison between the deprecated model and the new version for a particular difficult scene: a plane and a single point light. </p><div class="image">
<img src="cpa1_plane_pointlight.png" alt="cpa1_plane_pointlight.png"/>
<div class="caption">
The deprecated version shows serious block artefacts and the overall flake distribution does not match the BRDF well</div></div>
 <div class="image">
<img src="cpa2_plane_pointlight.png" alt="cpa2_plane_pointlight.png"/>
<div class="caption">
The new version does not show block artefacts and the flake distribution matches the BRDF well</div></div>
<p> The new model consists of three main components: first, a brightness BRDF part which models the angular brightness variation of the paint, second, a angular dependent color table which captures low-frequency color shift of modern effect paints and, finally, a BTF part which captures the visible flakes. Furthermore, a refractive or non-refractive clear coat layer with orange peel as described in Section <a class="el" href="page1.html#svbrdf_subsec03">Coated SVBRDFs</a> is supported. <br />
 In the following sections you find and a brief introduction for each of the different model components.</p>
<h2><a class="anchor" id="carpaint_BrightnessBRDF"></a>
Brightness BRDF</h2>
<p>The BRDF is modeled using a multi-lobe Cook-Torrance: </p><p class="formulaDsp">
\[ f(\bar{\mathbf{i}},\bar{\mathbf{o}})=\frac{a}{\pi}+\sum_{k=1}^{K}\frac{s_k}{\pi}\frac{D_{\alpha_k}(\bar{\mathbf{h}})F_{F_{0,k}}(\bar{\mathbf{h}},\bar{\mathbf{o}})G(\bar{\mathbf{i}},\bar{\mathbf{o}})}{\bar{i}_z \bar{o}_z} \]
</p>
<p> We use the Beckmann distribution, the original geometry term <a class="el" href="citelist.html#CITEREF_Cook:1982:RMC">[1]</a> and Schlick's Fresnel approximation. Although not finally decided yet <em>K=3</em> is the default number of lobes and can be assumed as de-facto standard. Please note the bars over the direction vectors which indicate that all directions used in the model are defined <em>below</em> the clear coat as defined in <a class="el" href="page1.html#svbrdf_subsec03">Coated SVBRDFs</a>. In this case, e.g., the incoming direction is a refracted direction \(\bar{\mathbf{i}}=\textbf{refract}(\mathbf{i},n_{cc},n_{air})\) whereas \(n_{cc}\) denotes the (measured) clear coat's index of refraction. The other directions are defined accordingly. Nonetheless, the model can also be used without a clear coat on top. <br />
 A typical implementation of this BRDF in GLSL looks as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> CT(in vec3 wi_l, in vec3 wo_l)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> MIN_THETA = float(1E-8);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> min_dist = 0.6;</div><div class="line"></div><div class="line">    vec3 wh = normalize(wi_l+wo_l);</div><div class="line">    <span class="keywordtype">float</span> N_V = wo_l.z;</div><div class="line">    <span class="keywordtype">float</span> N_L = wi_l.z;</div><div class="line">    <span class="keywordtype">float</span> N_H = wh.z;</div><div class="line">    <span class="keywordtype">float</span> H_L = dot(wi_l, wh);</div><div class="line">    <span class="keywordtype">float</span> H_V = dot(wo_l, wh);</div><div class="line"></div><div class="line">    <span class="comment">//ensure numerical stability</span></div><div class="line">    <span class="keywordflow">if</span> ( (N_V &lt; 0.00174532836589830883577820272085  <span class="comment">//sin(0.1°)</span></div><div class="line">            &amp;&amp; N_L &lt; 0.00174532836589830883577820272085) )</div><div class="line">        <span class="keywordflow">return</span> 0.0;</div><div class="line"></div><div class="line">    <span class="comment">//diffuse term</span></div><div class="line">    <span class="keywordtype">float</span> result = CT_diffuse * M_1_PI;</div><div class="line"></div><div class="line">    <span class="comment">//specular term</span></div><div class="line">    <span class="keywordtype">float</span> scale = CT_G(N_H, N_V, N_L, H_V) / (M_PI*N_V*N_L);    </div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> k=0; k&lt;NUM_LOBES; k++ )</div><div class="line">    {</div><div class="line">        <span class="keywordtype">float</span> spread = CT_spreads[k];</div><div class="line">        <span class="keywordtype">float</span> lobe = CT_coeffs[k] * CT_D(N_H,spread) * CT_F(H_V,CT_F0s[k]) * scale;</div><div class="line">        result += lobe;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p>whereas</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> CT_D(<span class="keywordtype">float</span> N_H, <span class="keywordtype">float</span> m)</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> cosb_sqr = N_H*N_H;</div><div class="line">    <span class="keywordtype">float</span> m_sqr = m*m;</div><div class="line">    <span class="keywordtype">float</span> e = (cosb_sqr-1.0)/(cosb_sqr*m_sqr);</div><div class="line">    <span class="keywordflow">return</span> exp(e) / (m_sqr*cosb_sqr*cosb_sqr);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">float</span> CT_F(<span class="keywordtype">float</span> H_V, <span class="keywordtype">float</span> F0)</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> f_1_sub_cos = 1.0-H_V;</div><div class="line">    <span class="keywordtype">float</span> f_1_sub_cos_sqr = f_1_sub_cos*f_1_sub_cos;</div><div class="line">    <span class="keywordtype">float</span> f_1_sub_cos_fifth= f_1_sub_cos_sqr*f_1_sub_cos_sqr*f_1_sub_cos;</div><div class="line">    <span class="keywordflow">return</span> F0 + (float(1.0)-F0)*f_1_sub_cos_fifth;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">float</span> CT_G(<span class="keywordtype">float</span> N_H, <span class="keywordtype">float</span> N_V, <span class="keywordtype">float</span> N_L, <span class="keywordtype">float</span> H_V)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> min(1.0, min( (2.0 * N_H * N_V / H_V),   (2.0 * N_H * N_L / H_V)));</div><div class="line">}</div></div><!-- fragment --><p> The uniform parameters used by the shader are referenced in <a class="el" href="page2.html#carpaint_Summary">Summary</a>.</p>
<h2><a class="anchor" id="carpaint_ColorTable"></a>
Color Table</h2>
<p>The brightness term is modulated by a 2D color table \(\chi(\cdot,\cdot)\) parameterized by the angle between half vector and normal \(\theta_{\bar{\mathbf{h}}}=\arccos(\bar{h}_z)\) and the angle between half vector and incoming direction \(\theta_{\bar{\mathbf{i}}}=\arccos(\left&lt;\bar{\mathbf{h}},\bar{\mathbf{i}}\right&gt;)\). In classical microfacet modeling \(\theta_{\bar{\mathbf{h}}}\) is interpreted as the angle between the overall surface normal and the microfacet normal. In the case of a metallic paint we identify microfacets with metallic flakes, hence \(\theta_{\bar{\mathbf{h}}}\) can be interpreted as the angle between the overall surface normal and the normal of a flake (modeled as a perfect mirror - this also explains why the \(\theta_{\bar{\mathbf{h}}}\) variables in the following pseudo-code are named by <em>thetaF</em> instead of <em>thetaH</em>). Correspondingly, \(\theta_{\bar{\mathbf{i}}}\) is the angle between the refracted illumination direction and the flake normal.</p>
<p>Consequently, the full colored BRDF could be implemented as follows: </p><div class="fragment"><div class="line">vec3 CPA2_BRDF(in vec3 wo_trans, in vec3 wi_trans)</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> f_bright = CT(wi_trans,wo_trans);</div><div class="line">    </div><div class="line">    vec3 v3_half = normalize(wi_trans + wo_trans);</div><div class="line">    <span class="keywordtype">float</span> f_thetaF = acos(clamp(v3_half.z,-1,1));</div><div class="line">    <span class="keywordtype">float</span> f_thetaI = acos(clamp(dot(v3_half,wi_trans),-1,1));</div><div class="line">    </div><div class="line">    vec3 v3_color = texture(BRDFcolors, vec2(f_thetaF/M_PI_2, f_thetaI/M_PI_2)).xyz;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> f_bright*v3_color;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="carpaint_FlakeBTF"></a>
Flake BTF Textures</h2>
<p>The spatially varying part, i.e. the visible flakes, is also parameterized based on \(\theta_{\bar{\mathbf{h}}}\) and \(\theta_{\bar{\mathbf{i}}}\) but now each entry does not contain a single color value but a complete flake texture slice as shown below: </p><div class="image">
<img src="flake_slice.png" alt="flake_slice.png"/>
<div class="caption">
Single flake texture slice</div></div>
<p> This arrangement actually leads to a 4-D table \(\Xi(\mathbf{x}, \theta_{\bar{\mathbf{h}}}, \theta_{\bar{\mathbf{i}}})\). In practice the sampling of the angular space can actually be quite sparse. First, as shown in <a class="el" href="citelist.html#CITEREF_rump-vmv-09">[6]</a> the typical angular lifetime of flakes is around 6-7° which means that a sampling grid size of about 24-30 samples along each direction should be sufficient to convey a realistic and smooth fading of flakes. Second, the index of refraction of paint binder is usually around 1.5 which compresses the angular space towards the surface normal and renders almost all flake images with \(\theta_{\bar{\mathbf{h}}}&gt;45°\) zero. Consequently, we store for each fixed illumination sample grid point \(\theta_{\bar{\mathbf{i}}_j}\) only the non-zero flake texture bins \(\theta_{\bar{\mathbf{h}}_k}\) which is usually significantly less than storing the full upper triangular part of \(\Xi(\cdot, \theta_{\bar{\mathbf{h}}}, \theta_{\bar{\mathbf{i}}})\).</p>
<p>Furthermore, for most paints the spatial distribution of flakes depends mainly on their orientation, i.e. on \(\theta_{\bar{\mathbf{h}}}\), while the low frequency color changes due to interference effect pigments occur along the illumination direction. Therefore, for the sampling along the \(\theta_{\bar{\mathbf{i}}}\) direction often less samples can be used. In order to preserve the angular flake lifetime "virtual" sample points can be added based on <em>shuffled</em> versions of the original textures.</p>
<p>Interpolated access to this 4D table and also the insertion of virtual sample points could be implemented in GLSL as follows:</p>
<div class="fragment"><div class="line">vec3 CPA2_BTF(in vec3 wo_trans, in vec3 wi_trans, in vec2 texCoord)</div><div class="line">{</div><div class="line">    vec2 uv = texCoord;</div><div class="line">    <span class="comment">//hide tiles by mirroring</span></div><div class="line">    <span class="keywordflow">if</span> (0==(<span class="keywordtype">int</span>(uv[1])%2))</div><div class="line">    {</div><div class="line">        uv[0]+=0.5f;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0==(<span class="keywordtype">int</span>(uv[0])%3))</div><div class="line">    {</div><div class="line">        uv[1] = 1-uv[1];</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        uv[0] = 1-uv[0];</div><div class="line">    }</div><div class="line"></div><div class="line">    vec3 v3_half = normalize(wi_trans + wo_trans);</div><div class="line">    <span class="keywordtype">float</span> f_thetaF = clamp(acos(clamp(v3_half.z,-1,1)),0,1);</div><div class="line">    <span class="keywordtype">float</span> f_thetaI = clamp(acos(clamp(dot(v3_half,wi_trans),-1,1)),0,1);</div><div class="line"></div><div class="line">    <span class="comment">//thetaF sampling defines the angular sampling, i.e. angular flake lifetime</span></div><div class="line">    <span class="keywordtype">int</span> i_angular_sampling = num_thetaF;</div><div class="line">    f_thetaF = (f_thetaF/M_PI_2*float(i_angular_sampling))+0.5;</div><div class="line">    f_thetaI = (f_thetaI/M_PI_2*float(i_angular_sampling))+0.5;</div><div class="line"></div><div class="line">    <span class="comment">//bilinear interp indices and weights</span></div><div class="line">    <span class="keywordtype">int</span> i_thetaF_low = int(floor(f_thetaF));</div><div class="line">    <span class="keywordtype">int</span> i_thetaF_high = i_thetaF_low+1;</div><div class="line">    <span class="keywordtype">int</span> i_thetaI_low = int(floor(f_thetaI));</div><div class="line">    <span class="keywordtype">int</span> i_thetaI_high = i_thetaI_low+1;</div><div class="line"></div><div class="line">    <span class="keywordtype">float</span> f_thetaF_w = f_thetaF - float(i_thetaF_low);</div><div class="line">    <span class="keywordtype">float</span> f_thetaI_w = f_thetaI - float(i_thetaI_low);</div><div class="line"></div><div class="line">    <span class="comment">//  to allow lower thetaI samplings while preserving flake lifetime </span></div><div class="line">    <span class="comment">//&quot;virtual&quot; thetaI patches are generated by shifting existing ones </span></div><div class="line">    vec2 v2_offset_l = vec2(0,0);   </div><div class="line">    vec2 v2_offset_h = vec2(0,0);   </div><div class="line">    <span class="keywordflow">if</span> ( num_thetaI &lt; i_angular_sampling )</div><div class="line">    {</div><div class="line">        v2_offset_l = vec2(rnd_numbers[2*i_thetaI_low],rnd_numbers[2*i_thetaI_low+1]);</div><div class="line">        v2_offset_h = vec2(rnd_numbers[2*i_thetaI_high],rnd_numbers[2*i_thetaI_high+1]);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (i_thetaI_low%2==1) uv.xy = uv.yx;</div><div class="line">        <span class="keywordflow">if</span> (i_thetaI_high%2==1) uv.xy = uv.yx;</div><div class="line"></div><div class="line">        <span class="comment">//map to the original sampling</span></div><div class="line">        i_thetaI_low = int(floor(i_thetaI_low*<span class="keywordtype">float</span>(num_thetaI)/<span class="keywordtype">float</span>(num_thetaF)));</div><div class="line">        i_thetaI_high = int(floor(i_thetaI_high*<span class="keywordtype">float</span>(num_thetaI)/<span class="keywordtype">float</span>(num_thetaF)));</div><div class="line">    }</div><div class="line"></div><div class="line">    vec3 v3_ll = vec3(0,0,0);</div><div class="line">    vec3 v3_lh = vec3(0,0,0);</div><div class="line">    vec3 v3_hl = vec3(0,0,0);</div><div class="line">    vec3 v3_hh = vec3(0,0,0);</div><div class="line">    <span class="comment">//access flake texture - make sure to stay in the correct slices (no slip over)</span></div><div class="line">    <span class="keywordflow">if</span> (i_thetaI_low&lt;max_thetaI)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> ( thetaFI_sliceLUT[i_thetaI_low]+i_thetaF_low &lt; thetaFI_sliceLUT[i_thetaI_low+1] )</div><div class="line">        {</div><div class="line">            v3_ll = texture(BTFflakes, vec3(uv+v2_offset_l,thetaFI_sliceLUT[i_thetaI_low]+i_thetaF_low)).xyz;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> ( thetaFI_sliceLUT[i_thetaI_low]+i_thetaF_high &lt; thetaFI_sliceLUT[i_thetaI_low+1] )</div><div class="line">        {</div><div class="line">            v3_hl = texture(BTFflakes, vec3(uv+v2_offset_l,thetaFI_sliceLUT[i_thetaI_low]+i_thetaF_high)).xyz;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (i_thetaI_high&lt;max_thetaI)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> ( thetaFI_sliceLUT[i_thetaI_high]+i_thetaF_low &lt; thetaFI_sliceLUT[i_thetaI_high+1] )</div><div class="line">        {</div><div class="line">            v3_lh = texture(BTFflakes, vec3(uv+v2_offset_h,thetaFI_sliceLUT[i_thetaI_high]+i_thetaF_low)).xyz;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> ( thetaFI_sliceLUT[i_thetaI_high]+i_thetaF_high &lt; thetaFI_sliceLUT[i_thetaI_high+1] )</div><div class="line">        {</div><div class="line">            v3_hh = texture(BTFflakes, vec3(uv+v2_offset_h,thetaFI_sliceLUT[i_thetaI_high]+i_thetaF_high)).xyz;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="comment">//bilinear interpolation</span></div><div class="line">    vec3 v3_l = (1-f_thetaF_w) * v3_ll + f_thetaF_w * v3_hl;</div><div class="line">    vec3 v3_h = (1-f_thetaF_w) * v3_lh + f_thetaF_w * v3_hh;    </div><div class="line">    <span class="keywordflow">return</span> (1-f_thetaI_w) * v3_l + f_thetaI_w * v3_h;</div><div class="line">}</div></div><!-- fragment --><p> The texture and uniform parameters used by the shader are described below in <a class="el" href="page2.html#carpaint_Summary">Summary</a>. The 4D <em>BTFflakes</em> texture is technically represented by a texture array with the \(\theta_{\bar{\mathbf{i}}_j}\) and \(\theta_{\bar{\mathbf{h}}_k}\) bins enrolled along the array dimension (see also the description of the <em>thetaFI_sliceLUT</em> property below).</p>
<h2><a class="anchor" id="carpaint_combined"></a>
Combined model</h2>
<p>To summarize, the complete spatially varying paint model <em>below clear coat</em> reads as follows: </p><p class="formulaDsp">
\[ f(\mathbf{x},\bar{\mathbf{i}},\bar{\mathbf{o}}) = \chi(\theta_{\bar{\mathbf{h}}},\theta_{\bar{\mathbf{i}}})\left(\frac{a}{\pi}+\sum_{k=1}^{3}f^{CT}_{s_k,\alpha_k,F_{0,k}}(\bar{\mathbf{i}},\bar{\mathbf{o}}) \right)+ \Xi(\mathbf{x}, \theta_{\bar{\mathbf{h}}}, \theta_{\bar{\mathbf{i}}}) \]
</p>
<h2><a class="anchor" id="carpaint_Summary"></a>
Summary</h2>
<p>As detailed in <a class="el" href="page1.html#svbrdf_sec03">SVRDF Implementation Guideline</a> we recommend to utilize the <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html" title="Decodes texture resources from AxF representations. ">axf::decoding::TextureDecoder</a> interface to query (texture) resources and parameters from the AxF. The following table gives an overview on the returned objects for the AxF representation class <em>CarPaint2</em>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Texture name  </th><th class="markdownTableHeadNone">#define (<a class="el" href="_ax_f__basic__io_8h_source.html">AxF_basic_io.h</a>)  </th><th class="markdownTableHeadNone">AxF Version  </th><th class="markdownTableHeadNone">Semantic   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">BRDFcolors  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_TEXTURE_NAME_BRDF_COLORS  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone">\(\chi(\theta_\bar{\mathbf{h}},\theta_\bar{\mathbf{i}})\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">BTFflakes  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_TEXTURE_NAME_BTF_FLAKES  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone">\(\Xi(\mathbf{x}, \theta_\bar{\mathbf{h}}, \theta_\bar{\mathbf{i}})\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ClearcoatNormal  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_TEXTURE_NAME_CLEARCOAT_NORMAL  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone">\((X,Y,Z)\)   </td></tr>
</table>
<p>Similarly, the representation's properties whose names are returned by the method <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a1577a9de4c6919c775ccc4fc94c5c727" title="Returns the name, i.e. semantic of the given property. AXF_MAX_KEY_SIZE is sufficient for iBufSize...">axf::decoding::TextureDecoder::getPropertyName()</a> for <em>CarPaint2</em> and ID_DEFAULT are as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Property name  </th><th class="markdownTableHeadNone">#define (<a class="el" href="_ax_f__basic__io_8h_source.html">AxF_basic_io.h</a>)  </th><th class="markdownTableHeadNone">AxF Version  </th><th class="markdownTableHeadNone">Type  </th><th class="markdownTableHeadNone">Semantic   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CT_diffuse  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_PROPERTY_BRDF_CT_DIFFUSE  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba935cfd3460d502bd67618a724ef0c9bc" title="32-bit IEEE single-precision floating point ">axf::decoding::TYPE_FLOAT</a>  </td><td class="markdownTableBodyNone">\( a\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">CT_coeffs  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_PROPERTY_BRDF_CT_COEFFS  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba88007b5d9b319d3ec7d78dc7fb264071" title="array of TYPE_FLOAT ">axf::decoding::TYPE_FLOAT_ARRAY</a>  </td><td class="markdownTableBodyNone">\(\{s_k\}\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">CT_F0s  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_PROPERTY_BRDF_CT_F0S  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba88007b5d9b319d3ec7d78dc7fb264071" title="array of TYPE_FLOAT ">axf::decoding::TYPE_FLOAT_ARRAY</a>  </td><td class="markdownTableBodyNone">\(\{F_{0,k}\}\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">CT_spreads  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_PROPERTY_BRDF_CT_SPREADS  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba88007b5d9b319d3ec7d78dc7fb264071" title="array of TYPE_FLOAT ">axf::decoding::TYPE_FLOAT_ARRAY</a>  </td><td class="markdownTableBodyNone">\(\{\alpha_k\}\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">num_thetaF  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_PROPERTY_FLAKES_NUM_THETAF  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba3f466f5fd483716a0eea0f93ab580962" title="32-bit signed integer ">axf::decoding::TYPE_INT</a>  </td><td class="markdownTableBodyNone">number of \(\theta_F\) bins   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">num_thetaI  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_PROPERTY_FLAKES_NUM_THETAI  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba3f466f5fd483716a0eea0f93ab580962" title="32-bit signed integer ">axf::decoding::TYPE_INT</a>  </td><td class="markdownTableBodyNone">number of \(\theta_I\) bins   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">max_thetaI  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_PROPERTY_FLAKES_MAX_THETAI  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba3f466f5fd483716a0eea0f93ab580962" title="32-bit signed integer ">axf::decoding::TYPE_INT</a>  </td><td class="markdownTableBodyNone">max \(\theta_I\) bin actually used   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">thetaFI_sliceLUT  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_PROPERTY_FLAKES_THETAFI_SLICE_LUT  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350bab84b06ca6591ada0e6b0eec51e40b6df" title="array of TYPE_INT ">axf::decoding::TYPE_INT_ARRAY</a>  </td><td class="markdownTableBodyNone">index into flake texture array for a given \(\theta_I\) bin   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">IOR  </td><td class="markdownTableBodyNone">AXF_CARPAINT2_PROPERTY_CC_IOR  </td><td class="markdownTableBodyNone">1.2  </td><td class="markdownTableBodyNone"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba935cfd3460d502bd67618a724ef0c9bc" title="32-bit IEEE single-precision floating point ">axf::decoding::TYPE_FLOAT</a>  </td><td class="markdownTableBodyNone">index of refraction, equals 1 in case of no clear coat   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">cc_no_refraction  </td><td class="markdownTableBodyNone">AXF_CLEARCOAT_PROPERTY_NAME_NO_REFRACTION  </td><td class="markdownTableBodyNone">1.3  </td><td class="markdownTableBodyNone"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba3f466f5fd483716a0eea0f93ab580962" title="32-bit signed integer ">axf::decoding::TYPE_INT</a>  </td><td class="markdownTableBodyNone">nonzero if clear coat does <em>not</em> refract transmitted rays   </td></tr>
</table>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 18 2018 00:04:38 for AxF Decoding SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
