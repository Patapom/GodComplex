<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AxF Decoding SDK: axf::decoding::CPUDecoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="AxF-SDK-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AxF Decoding SDK
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">Decoding AxF representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>axf</b></li><li class="navelem"><a class="el" href="namespaceaxf_1_1decoding.html">decoding</a></li><li class="navelem"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html">CPUDecoder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classaxf_1_1decoding_1_1_c_p_u_decoder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">axf::decoding::CPUDecoder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Decodes AxF representations on the CPU.  
 <a href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaxf_1_1decoding_1_1_c_p_u_decoder_1_1_deleter.html">Deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For using shared_ptr&lt;CPUDecoder&gt;, pass this as second parameter to the shared_ptr constructor.  <a href="structaxf_1_1decoding_1_1_c_p_u_decoder_1_1_deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a536cbd25732c040e14d938be4a6dc2fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#a536cbd25732c040e14d938be4a6dc2fb">eval</a> (float *pfResult, float *pfAlpha, const float *v3DirIn, const float *v3DirOut, const float *v2UV) const</td></tr>
<tr class="memdesc:a536cbd25732c040e14d938be4a6dc2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the material's reflectance function in the target color space.  <a href="#a536cbd25732c040e14d938be4a6dc2fb">More...</a><br /></td></tr>
<tr class="separator:a536cbd25732c040e14d938be4a6dc2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Convenience functions (for computing preview images)</div></td></tr>
<tr class="memitem:a1cf8efe7efca65a4575ea5e079962eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#a1cf8efe7efca65a4575ea5e079962eef">computePreviewImage</a> (float *pImage, int iWidthPixel, int iHeightPixel, int iChannels, float fWidthMM, float fHeightMM)</td></tr>
<tr class="memdesc:a1cf8efe7efca65a4575ea5e079962eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute simple planar preview image.  <a href="#a1cf8efe7efca65a4575ea5e079962eef">More...</a><br /></td></tr>
<tr class="separator:a1cf8efe7efca65a4575ea5e079962eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231beefa9d2d7bd02a2cb2c4f5e53dbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#a231beefa9d2d7bd02a2cb2c4f5e53dbc">computePreviewImage</a> (float *pColorImage, float *pAlphaImage, int iWidthPixel, int iHeightPixel, float fWidthMM, float fHeightMM)</td></tr>
<tr class="memdesc:a231beefa9d2d7bd02a2cb2c4f5e53dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute simple planar preview image (variant with non-interleaved color and alpha images)  <a href="#a231beefa9d2d7bd02a2cb2c4f5e53dbc">More...</a><br /></td></tr>
<tr class="separator:a231beefa9d2d7bd02a2cb2c4f5e53dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add347e93fc9cbbb98bc1dd5cb34000c2"><td class="memItemLeft" align="right" valign="top"><a id="add347e93fc9cbbb98bc1dd5cb34000c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#add347e93fc9cbbb98bc1dd5cb34000c2">computePreviewImage</a> (float *pColorImage, float *pAlphaImage, int iSizePixel, float fSizeMM)</td></tr>
<tr class="memdesc:add347e93fc9cbbb98bc1dd5cb34000c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED variant of the function: equivalent to computePreviewImage(pColorImage, pAlphaImage, iSizePixel, iSizePixel, fSizeMM, fSizeMM) <br /></td></tr>
<tr class="separator:add347e93fc9cbbb98bc1dd5cb34000c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information about the decoded representation</div></td></tr>
<tr class="memitem:ade30dfc44121361317b0588eedd2f69a"><td class="memItemLeft" align="right" valign="top"><a id="ade30dfc44121361317b0588eedd2f69a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#ade30dfc44121361317b0588eedd2f69a">getWidthPixel</a> () const</td></tr>
<tr class="memdesc:ade30dfc44121361317b0588eedd2f69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get width of the representation in pixels. <br /></td></tr>
<tr class="separator:ade30dfc44121361317b0588eedd2f69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bae37bbd39e62a0a29e026b390d3a6"><td class="memItemLeft" align="right" valign="top"><a id="a32bae37bbd39e62a0a29e026b390d3a6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#a32bae37bbd39e62a0a29e026b390d3a6">getHeightPixel</a> () const</td></tr>
<tr class="memdesc:a32bae37bbd39e62a0a29e026b390d3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get height of the representation in pixels. <br /></td></tr>
<tr class="separator:a32bae37bbd39e62a0a29e026b390d3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ffb5c7bdeee0f952dfc4134f25a9f9"><td class="memItemLeft" align="right" valign="top"><a id="aa3ffb5c7bdeee0f952dfc4134f25a9f9"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#aa3ffb5c7bdeee0f952dfc4134f25a9f9">getWidthMM</a> () const</td></tr>
<tr class="memdesc:aa3ffb5c7bdeee0f952dfc4134f25a9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get width of the representation in millimeters. <br /></td></tr>
<tr class="separator:aa3ffb5c7bdeee0f952dfc4134f25a9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfeb8623fc9fd90d691d58a4c5b87f32"><td class="memItemLeft" align="right" valign="top"><a id="adfeb8623fc9fd90d691d58a4c5b87f32"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#adfeb8623fc9fd90d691d58a4c5b87f32">getHeightMM</a> () const</td></tr>
<tr class="memdesc:adfeb8623fc9fd90d691d58a4c5b87f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get height of the representation in millimeters. <br /></td></tr>
<tr class="separator:adfeb8623fc9fd90d691d58a4c5b87f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2fec4a082fee5b6efa089b6e5eca4d"><td class="memItemLeft" align="right" valign="top"><a id="a1f2fec4a082fee5b6efa089b6e5eca4d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#a1f2fec4a082fee5b6efa089b6e5eca4d">hasTransparency</a> () const</td></tr>
<tr class="memdesc:a1f2fec4a082fee5b6efa089b6e5eca4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the representation contains an alpha map that specifies transparency. <br /></td></tr>
<tr class="separator:a1f2fec4a082fee5b6efa089b6e5eca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Factory interface</h2></td></tr>
<tr class="memitem:a0219703dee919419659a1c7976683db3"><td class="memItemLeft" align="right" valign="top"><a id="a0219703dee919419659a1c7976683db3"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>getTargetColorSpaceString</b> () const</td></tr>
<tr class="separator:a0219703dee919419659a1c7976683db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f234b0088ad5fbcb6a0fbfa7f49565"><td class="memItemLeft" align="right" valign="top"><a id="a81f234b0088ad5fbcb6a0fbfa7f49565"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getTargetTextureOrigin</b> () const</td></tr>
<tr class="separator:a81f234b0088ad5fbcb6a0fbfa7f49565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ed2680d0246d545401c3196dd71f30"><td class="memItemLeft" align="right" valign="top"><a id="af7ed2680d0246d545401c3196dd71f30"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#af7ed2680d0246d545401c3196dd71f30">destroy</a> ()</td></tr>
<tr class="memdesc:af7ed2680d0246d545401c3196dd71f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html" title="Decodes AxF representations on the CPU. ">CPUDecoder</a> instance. <br /></td></tr>
<tr class="separator:af7ed2680d0246d545401c3196dd71f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb81a71521ab469e5c85b4e81c07f7f6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html">CPUDecoder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#acb81a71521ab469e5c85b4e81c07f7f6">create</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, const char *sTargetColorSpace, int iTextureOrigin=<a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546af81cf674c1146c260fd907f0794d252b">ORIGIN_BOTTOMLEFT</a>)</td></tr>
<tr class="memdesc:acb81a71521ab469e5c85b4e81c07f7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture decoder for a given AxF representation, target color space and target system ID.  <a href="#acb81a71521ab469e5c85b4e81c07f7f6">More...</a><br /></td></tr>
<tr class="separator:acb81a71521ab469e5c85b4e81c07f7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23da6e3da41c5e3d71d4726589d539b"><td class="memItemLeft" align="right" valign="top"><a id="af23da6e3da41c5e3d71d4726589d539b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#af23da6e3da41c5e3d71d4726589d539b">destroy</a> (<a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html">CPUDecoder</a> **ppCPUDecoder)</td></tr>
<tr class="memdesc:af23da6e3da41c5e3d71d4726589d539b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#af7ed2680d0246d545401c3196dd71f30" title="Destroys CPUDecoder instance. ">destroy()</a>: destroys **ppCPUDecoder and additionally sets *ppCPUDecoder to NULL. <br /></td></tr>
<tr class="separator:af23da6e3da41c5e3d71d4726589d539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Decodes AxF representations on the CPU using a basic <em>BTF</em> or <em>SVBRDF</em>-like interface respectively. A spatially varying BRDF is a seven-dimensional function \( f(\lambda,u,v,\theta_i,\phi_i,\theta_o,\phi_o) \) whereas \(\lambda\) is wavelength, \(u,v\) are the 2D surface coordinates the material is attached to and \(\theta_i,\phi_i,\theta_o,\phi_o\) are the in- and outgoing angles respectively. Note that the returned results include the cosine term, i.e. the BRDF is multiplied with &lt;N,L&gt;.</p>
<p>The interface should be mainly used for quickly integrating AxF representation decoding into CPU based renderers like ray- or pathtracers. For Monte-Carlo raytracers the <a class="el" href="classaxf_1_1decoding_1_1_sampler.html" title="Samples AxF representations on the CPU. ">Sampler</a> interface is provided. Basic usage: </p><div class="fragment"><div class="line">AXF_REPRESENTATION_HANDLE h_axf_rep = <a class="code" href="namespaceaxf_1_1decoding.html#a36755ec273d115909eefb03268beec0c">axfGetPreferredRepresentation</a>( h_axf_file );</div><div class="line">CPUDecoder* pcl_decoder = <a class="code" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#acb81a71521ab469e5c85b4e81c07f7f6">CPUDecoder::create</a>( h_axf_rep, <span class="stringliteral">&quot;sRGB,E&quot;</span> );</div><div class="line">...</div><div class="line">\\collect incoming, outgoing, UV; assume trichromatic color space + alpha channel</div><div class="line"><span class="keywordtype">float</span> f4_result_rgba[4];</div><div class="line">pcl_decoder-&gt;eval( f4_result_rgba, f4_result_rgba+3, wi, wo, uv );</div><div class="line">...</div><div class="line">pcl_decoder-&gt;destroy();</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_c_p_u_decoder_8h_source.html#l00063">63</a> of file <a class="el" href="_c_p_u_decoder_8h_source.html">CPUDecoder.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a536cbd25732c040e14d938be4a6dc2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536cbd25732c040e14d938be4a6dc2fb">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void axf::decoding::CPUDecoder::eval </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pfAlpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>v3DirIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>v3DirOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>v2UV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfResult</td><td>pointer to a buffer (of 3 floats) to receive the per-color-channel values of the materials reflectance function (BRDF multiplied by cosine term) for the given parameters </td></tr>
    <tr><td class="paramname">pfAlpha</td><td>optional pointer to a buffer (of 1 float); unless this is a null pointer, *pfAlpha receives an alpha/opacity value for representations with transparency (see <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#a1f2fec4a082fee5b6efa089b6e5eca4d" title="Indicates whether the representation contains an alpha map that specifies transparency. ">hasTransparency()</a>) or 1.0f otherwise </td></tr>
    <tr><td class="paramname">v3DirIn</td><td>Normalized direction specifying the incoming (light direction) in local tangent space </td></tr>
    <tr><td class="paramname">v3DirOut</td><td>Normalized direction specifying the outgoing (view direction) in local tangent space </td></tr>
    <tr><td class="paramname">v2UV</td><td>Normalized UV coordinate \(u,v \in [0,1)\) specifying the location on the material</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the values stored in pfResult are in the target color space that was specified in the call to <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#acb81a71521ab469e5c85b4e81c07f7f6" title="Create a texture decoder for a given AxF representation, target color space and target system ID...">create()</a>. In any case, the returned values are trichromatic (3 float values) since currently only trichromatic target color spaces can be specified. </p>

</div>
</div>
<a id="a1cf8efe7efca65a4575ea5e079962eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf8efe7efca65a4575ea5e079962eef">&#9670;&nbsp;</a></span>computePreviewImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void axf::decoding::CPUDecoder::computePreviewImage </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iWidthPixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iHeightPixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fWidthMM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fHeightMM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pImage</td><td>pointer to a buffer of iWidthPixel*iHeightPixel*iChannels floats to receive the preview image </td></tr>
    <tr><td class="paramname">iWidthPixel</td><td>width of the preview image in pixels </td></tr>
    <tr><td class="paramname">iHeightPixel</td><td>height of the preview image in pixels </td></tr>
    <tr><td class="paramname">iChannels</td><td>number of channels of the preview image (3 or 4) </td></tr>
    <tr><td class="paramname">fWidthMM</td><td>spatial width of the preview image in millimeters </td></tr>
    <tr><td class="paramname">fHeightMM</td><td>spatial height of the preview image in millimeters</td></tr>
  </table>
  </dd>
</dl>
<p>A simple preview image is computed with a central viewpoint and point light source placed above the planar sample geometry. The preview image is computed in the target color space that was specified in the call to <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#acb81a71521ab469e5c85b4e81c07f7f6" title="Create a texture decoder for a given AxF representation, target color space and target system ID...">create()</a>, which is trichromatic, and can optionally include an alpha channel.</p>
<p>Thus iChannels must be either 3 or 4:</p><ul>
<li>For iChannels = 3, a 3-channel color image (without alpha) is returned. If the decoded representation has transparency (see <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#a1f2fec4a082fee5b6efa089b6e5eca4d" title="Indicates whether the representation contains an alpha map that specifies transparency. ">hasTransparency()</a>), the material is rendered in front of a checkerboard background, which becomes "baked" into the resulting 3-channel image.</li>
<li>For iChannels = 4, a 4-channel color/alpha image is returned (e.g. RGBA). No background is integrated into the resulting image.</li>
</ul>
<p>If it is intented to store the computed preview image in the AxF file via axfStorePreviewImage(), it is recommended to choose iChannel = 4 if <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#a1f2fec4a082fee5b6efa089b6e5eca4d" title="Indicates whether the representation contains an alpha map that specifies transparency. ">hasTransparency()</a> is true, and iChannel = 3 otherwise. </p>

</div>
</div>
<a id="a231beefa9d2d7bd02a2cb2c4f5e53dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231beefa9d2d7bd02a2cb2c4f5e53dbc">&#9670;&nbsp;</a></span>computePreviewImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void axf::decoding::CPUDecoder::computePreviewImage </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pColorImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pAlphaImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iWidthPixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iHeightPixel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fWidthMM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fHeightMM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pColorImage</td><td>pointer to a buffer of iWidthPixel*iHeightPixel*3 floats to receive the preview image's color channels </td></tr>
    <tr><td class="paramname">pAlphaImage</td><td>optional pointer to a buffer of iWidthPixel*iHeightPixel floats to receive the preview image's alpha/opacity channel </td></tr>
    <tr><td class="paramname">iWidthPixel</td><td>width of the preview image in pixels </td></tr>
    <tr><td class="paramname">iHeightPixel</td><td>height of the preview image in pixels </td></tr>
    <tr><td class="paramname">fWidthMM</td><td>spatial width of the preview image in millimeters </td></tr>
    <tr><td class="paramname">fHeightMM</td><td>spatial height of the preview image in millimeters</td></tr>
  </table>
  </dd>
</dl>
<p>A simple preview image is computed with a central viewpoint and point light source placed above the planar sample geometry. The preview image is computed in the target color space that was specified in the call to <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#acb81a71521ab469e5c85b4e81c07f7f6" title="Create a texture decoder for a given AxF representation, target color space and target system ID...">create()</a>, which is trichromatic.</p>
<p>This variant of the function returns the computed color channels and alpha channel separately as 3-channel color image and 1-channel alpha image, respectively.</p>
<p>If pAlphaImage is null, no alpha image is returned. The returned color image is not affected by this. (So using this variant of <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#a1cf8efe7efca65a4575ea5e079962eef" title="Compute simple planar preview image. ">computePreviewImage()</a> with pAlphaImage = null is NOT equivalent to using the above variant with iChannels = 3 if the representation has transparency.) </p>

</div>
</div>
<a id="acb81a71521ab469e5c85b4e81c07f7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb81a71521ab469e5c85b4e81c07f7f6">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html">CPUDecoder</a>* axf::decoding::CPUDecoder::create </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sTargetColorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iTextureOrigin</em> = <code><a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546af81cf674c1146c260fd907f0794d252b">ORIGIN_BOTTOMLEFT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static factory method to create a <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html" title="Decodes AxF representations on the CPU. ">CPUDecoder</a> for given AxF representation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to AxF representation (cf. <a class="el" href="namespaceaxf_1_1decoding.html#a3c04510b187bd2d96d58d4f762e5c3b9" title="Return a handle to a specific representation of an AxF material. ">axfGetRepresentation()</a> etc.) </td></tr>
    <tr><td class="paramname">sTargetColorSpace</td><td>Trichromatic target color space (see below) </td></tr>
    <tr><td class="paramname">iTextureOrigin</td><td>cf. enum <a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546" title="Spatially varying textures need to have a defined embedding into 3D. ">ETextureOrigin</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html" title="Decodes AxF representations on the CPU. ">CPUDecoder</a> instance. Needs to be deallocated using <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#af7ed2680d0246d545401c3196dd71f30" title="Destroys CPUDecoder instance. ">destroy()</a>.</dd></dl>
<p>sTargetColorSpace must be one of:</p><ul>
<li>AXF_COLORSPACE_CIE_1931_XYZ ("XYZ"): the CIE 1931 XYZ color space</li>
<li>AXF_COLORSPACE_LINEAR_SRGB_E ("sRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the sRGB color space (IEC 61966-2-1), but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
<li>AXF_COLORSPACE_LINEAR_ADOBE_RGB_E ("AdobeRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the Adobe RGB (1988) color space, but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
<li>AXF_COLORSPACE_LINEAR_ADOBE_WIDEGAMUT_RGB_E ("WideGamutRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the Adobe Wide-Gamut RGB color space, but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
<li>AXF_COLORSPACE_LINEAR_PROPHOTO_RGB_E ("ProPhotoRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the ProPhoto RGB color space, but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
</ul>
<p>Note that all of the above options represent linear, trichromatic color spaces for the 2 degree standard observer. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 18 2018 00:04:38 for AxF Decoding SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
