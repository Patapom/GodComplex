<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AxF Decoding SDK: axf::decoding::TextureDecoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="AxF-SDK-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AxF Decoding SDK
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">Decoding AxF representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>axf</b></li><li class="navelem"><a class="el" href="namespaceaxf_1_1decoding.html">decoding</a></li><li class="navelem"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html">TextureDecoder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classaxf_1_1decoding_1_1_texture_decoder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">axf::decoding::TextureDecoder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Decodes texture resources from AxF representations.  
 <a href="classaxf_1_1decoding_1_1_texture_decoder.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaxf_1_1decoding_1_1_texture_decoder_1_1_deleter.html">Deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For using shared_ptr&lt;TextureDecoder&gt;, pass this as second parameter to the shared_ptr constructor.  <a href="structaxf_1_1decoding_1_1_texture_decoder_1_1_deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Dimensions</div></td></tr>
<tr class="memitem:a92be5164c0b3d7900c5bd460e0b40124"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a92be5164c0b3d7900c5bd460e0b40124">getWidthPixel</a> () const</td></tr>
<tr class="memdesc:a92be5164c0b3d7900c5bd460e0b40124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum width in pixels of all texture resources in this representation that are parameterized over the spatial U,V axes.  <a href="#a92be5164c0b3d7900c5bd460e0b40124">More...</a><br /></td></tr>
<tr class="separator:a92be5164c0b3d7900c5bd460e0b40124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37f57a2aedf7d331e4af38e87e0dd6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#ab37f57a2aedf7d331e4af38e87e0dd6a">getHeightPixel</a> () const</td></tr>
<tr class="memdesc:ab37f57a2aedf7d331e4af38e87e0dd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum height in pixels of all texture resources in this representation that are parameterized over the spatial U,V axes.  <a href="#ab37f57a2aedf7d331e4af38e87e0dd6a">More...</a><br /></td></tr>
<tr class="separator:ab37f57a2aedf7d331e4af38e87e0dd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac276a6c2dd013e7a9226b857c7940d89"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#ac276a6c2dd013e7a9226b857c7940d89">getWidthMM</a> () const</td></tr>
<tr class="memdesc:ac276a6c2dd013e7a9226b857c7940d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (maximum) physical width in millimeters of all texture resources in this representation that are parameterized over the spatial U,V axes.  <a href="#ac276a6c2dd013e7a9226b857c7940d89">More...</a><br /></td></tr>
<tr class="separator:ac276a6c2dd013e7a9226b857c7940d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85ae89e4f10b8a632b4a5139bb1ea05"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#ab85ae89e4f10b8a632b4a5139bb1ea05">getHeightMM</a> () const</td></tr>
<tr class="memdesc:ab85ae89e4f10b8a632b4a5139bb1ea05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (maximum) physical height in millimeters of all texture resources in this representation that are parameterized over the spatial U,V axes.  <a href="#ab85ae89e4f10b8a632b4a5139bb1ea05">More...</a><br /></td></tr>
<tr class="separator:ab85ae89e4f10b8a632b4a5139bb1ea05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Property interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods query and set parameters required to evaluate the representation correctly. These properties can be regarded as analogue to uniform variables in shader scripts. Type and value of these properties depend on the representation. </p>
</div></td></tr>
<tr class="memitem:ae21a3932cebf01986f8c4faf2399345b"><td class="memItemLeft" align="right" valign="top"><a id="ae21a3932cebf01986f8c4faf2399345b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#ae21a3932cebf01986f8c4faf2399345b">getNumProperties</a> () const</td></tr>
<tr class="memdesc:ae21a3932cebf01986f8c4faf2399345b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of properties. <br /></td></tr>
<tr class="separator:ae21a3932cebf01986f8c4faf2399345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd98cc05b52c427d575dded781b8a6e4"><td class="memItemLeft" align="right" valign="top"><a id="abd98cc05b52c427d575dded781b8a6e4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#abd98cc05b52c427d575dded781b8a6e4">getProperty</a> (int index, void *pBuf, int iDataType, int iSize) const</td></tr>
<tr class="memdesc:abd98cc05b52c427d575dded781b8a6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the property value. The buffer size iSize must be (at least) getPropertySize(index), and iDataType must match getPropertyType(index). <br /></td></tr>
<tr class="separator:abd98cc05b52c427d575dded781b8a6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1577a9de4c6919c775ccc4fc94c5c727"><td class="memItemLeft" align="right" valign="top"><a id="a1577a9de4c6919c775ccc4fc94c5c727"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a1577a9de4c6919c775ccc4fc94c5c727">getPropertyName</a> (int index, char *sBuf, int iBufSize) const</td></tr>
<tr class="memdesc:a1577a9de4c6919c775ccc4fc94c5c727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name, i.e. semantic of the given property. AXF_MAX_KEY_SIZE is sufficient for iBufSize. <br /></td></tr>
<tr class="separator:a1577a9de4c6919c775ccc4fc94c5c727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ce09800dbbfb6c28e203625270d8ee"><td class="memItemLeft" align="right" valign="top"><a id="ab7ce09800dbbfb6c28e203625270d8ee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getPropertyIndexFromName</b> (const char *sBuf) const</td></tr>
<tr class="separator:ab7ce09800dbbfb6c28e203625270d8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b041b30157039883cdf947f980bcae6"><td class="memItemLeft" align="right" valign="top"><a id="a6b041b30157039883cdf947f980bcae6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a6b041b30157039883cdf947f980bcae6">getPropertyType</a> (int index) const</td></tr>
<tr class="memdesc:a6b041b30157039883cdf947f980bcae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the given property (from enum <a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350b" title="Enum of property data types used in the metadata retrieval interface and TextureDecoder&#39;s property in...">axf::decoding::PropertyType</a>). For the current SDK version, this is always one of: TYPE_INT, TYPE_INT_ARRAY, TYPE_FLOAT, TYPE_FLOAT_ARRAY. <br /></td></tr>
<tr class="separator:a6b041b30157039883cdf947f980bcae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99da371b482e76b256f157c29ffc6402"><td class="memItemLeft" align="right" valign="top"><a id="a99da371b482e76b256f157c29ffc6402"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a99da371b482e76b256f157c29ffc6402">getPropertySize</a> (int index) const</td></tr>
<tr class="memdesc:a99da371b482e76b256f157c29ffc6402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the property value in <em>bytes</em>. <br /></td></tr>
<tr class="separator:a99da371b482e76b256f157c29ffc6402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe961e9c342f138c4833bebd92bd06d"><td class="memItemLeft" align="right" valign="top"><a id="aabe961e9c342f138c4833bebd92bd06d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getPropertyLen</b> (int index) const</td></tr>
<tr class="separator:aabe961e9c342f138c4833bebd92bd06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Texture interface</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are used to query the representations textures. The number, type, size and parameters of these textures depend on the representation. Please find detailed documentation on this in the representation documentation:</p><ul>
<li><a class="el" href="page1.html">SVBRDF Representation</a></li>
<li><a class="el" href="page2.html">Hybrid Model- and Image-based Carpaint Representation</a></li>
<li><a class="el" href="page3.html">Representations based on Matrix Factorization</a> </li>
</ul>
</div></td></tr>
<tr class="memitem:aef81d074a1fe4c408d815b12f11e90e3"><td class="memItemLeft" align="right" valign="top"><a id="aef81d074a1fe4c408d815b12f11e90e3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#aef81d074a1fe4c408d815b12f11e90e3">getNumTextures</a> () const</td></tr>
<tr class="memdesc:aef81d074a1fe4c408d815b12f11e90e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of textures. <br /></td></tr>
<tr class="separator:aef81d074a1fe4c408d815b12f11e90e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b816ee963186c6f459cf90d84de169"><td class="memItemLeft" align="right" valign="top"><a id="ab2b816ee963186c6f459cf90d84de169"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#ab2b816ee963186c6f459cf90d84de169">getTextureNumMipLevels</a> (int index) const</td></tr>
<tr class="memdesc:ab2b816ee963186c6f459cf90d84de169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of available mip-map levels for the given texture (1 if non-mipmap texture) <br /></td></tr>
<tr class="separator:ab2b816ee963186c6f459cf90d84de169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c1788ca4356f6814fab654cf07fef7"><td class="memItemLeft" align="right" valign="top"><a id="a57c1788ca4356f6814fab654cf07fef7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a57c1788ca4356f6814fab654cf07fef7">getTextureName</a> (int index, char *sBuf, int iBufSize) const</td></tr>
<tr class="memdesc:a57c1788ca4356f6814fab654cf07fef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name, i.e. semantic of the given texture (cf. <a class="el" href="page1.html#svbrdf_sec03">SVRDF Implementation Guideline</a>) <br /></td></tr>
<tr class="separator:a57c1788ca4356f6814fab654cf07fef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a4208ddfbf2311f5fb7799d5199375"><td class="memItemLeft" align="right" valign="top"><a id="a05a4208ddfbf2311f5fb7799d5199375"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getTextureParams</b> (int index, int &amp;iMinFilter, int &amp;iMagFilter, int &amp;iWrapS, int &amp;iWrapT, int &amp;iWrapR, bool &amp;bTextureArray) const</td></tr>
<tr class="separator:a05a4208ddfbf2311f5fb7799d5199375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54db6153d8b9058a1794bfadb26e5e2f"><td class="memItemLeft" align="right" valign="top"><a id="a54db6153d8b9058a1794bfadb26e5e2f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a54db6153d8b9058a1794bfadb26e5e2f">getTextureSize</a> (int index, int iMipLevel, int &amp;iWidth, int &amp;iHeight, int &amp;iDepth, int &amp;iChannels, int &amp;iStorageTextureType) const</td></tr>
<tr class="memdesc:a54db6153d8b9058a1794bfadb26e5e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the given texture in pixels, the number of channels, and the texture type in which the data is stored in the AxF file. <br /></td></tr>
<tr class="separator:a54db6153d8b9058a1794bfadb26e5e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49334f80849aa6ff85d14ed6dc7eb5aa"><td class="memItemLeft" align="right" valign="top"><a id="a49334f80849aa6ff85d14ed6dc7eb5aa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a49334f80849aa6ff85d14ed6dc7eb5aa">getTextureSizeMM</a> (int index, float &amp;fWidthMM, float &amp;fHeightMM) const</td></tr>
<tr class="memdesc:a49334f80849aa6ff85d14ed6dc7eb5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the physical width and height (corresponding to the spatial U,V axes) of the given texture in millimeters, provided that this texture is parameterized over the spatial U,V axes (0 otherwise) <br /></td></tr>
<tr class="separator:a49334f80849aa6ff85d14ed6dc7eb5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a828db702ab229008a3dbbe49067506a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a828db702ab229008a3dbbe49067506a8">getTextureData</a> (int index, int iMipLevel, int iTargetTextureType, void *pData) const</td></tr>
<tr class="separator:a828db702ab229008a3dbbe49067506a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Factory interface</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5af9fbbeeff5007d77ed4f4a54eebef4"></a> Create and destroy decoder instances </p>
</td></tr>
<tr class="memitem:af929ea96157764df4049c295dcc8d687"><td class="memItemLeft" align="right" valign="top"><a id="af929ea96157764df4049c295dcc8d687"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#af929ea96157764df4049c295dcc8d687">destroy</a> ()</td></tr>
<tr class="memdesc:af929ea96157764df4049c295dcc8d687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html" title="Decodes texture resources from AxF representations. ">TextureDecoder</a> instance (ensuring correct delete across DLL boundaries) <br /></td></tr>
<tr class="separator:af929ea96157764df4049c295dcc8d687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135b6c876ace1227a8e7dacac70ed09b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html">TextureDecoder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a135b6c876ace1227a8e7dacac70ed09b">create</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, const char *sTargetColorSpace, int iTextureOrigin=<a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546af81cf674c1146c260fd907f0794d252b">ORIGIN_BOTTOMLEFT</a>, int iTargetSystemID=<a class="el" href="namespaceaxf_1_1decoding.html#a16895524f5dc85432f79872337ca0659af8ce4fda422da8997469be1a787269a9">ID_DEFAULT</a>)</td></tr>
<tr class="memdesc:a135b6c876ace1227a8e7dacac70ed09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture decoder for a given AxF representation, target color space and target system ID.  <a href="#a135b6c876ace1227a8e7dacac70ed09b">More...</a><br /></td></tr>
<tr class="separator:a135b6c876ace1227a8e7dacac70ed09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c21976f06483120ad65a2ed90dd31e"><td class="memItemLeft" align="right" valign="top"><a id="a82c21976f06483120ad65a2ed90dd31e"></a>
static <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html">TextureDecoder</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a82c21976f06483120ad65a2ed90dd31e">create</a> (AXF_REPRESENTATION_HANDLE hAxFRepresentation, <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html">CPUDecoder</a> *pclCPUDecoder, int iTargetSystemID=<a class="el" href="namespaceaxf_1_1decoding.html#a16895524f5dc85432f79872337ca0659af8ce4fda422da8997469be1a787269a9">ID_DEFAULT</a>)</td></tr>
<tr class="memdesc:a82c21976f06483120ad65a2ed90dd31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a texture decoder for a given AxF representation, based on a <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html" title="Decodes AxF representations on the CPU. ">CPUDecoder</a> instance. <br /></td></tr>
<tr class="separator:a82c21976f06483120ad65a2ed90dd31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579f64f7f682e58d750a9502631e1036"><td class="memItemLeft" align="right" valign="top"><a id="a579f64f7f682e58d750a9502631e1036"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a579f64f7f682e58d750a9502631e1036">destroy</a> (<a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html">TextureDecoder</a> **ppTextureDecoder)</td></tr>
<tr class="memdesc:a579f64f7f682e58d750a9502631e1036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static version of <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#af929ea96157764df4049c295dcc8d687" title="Destroy TextureDecoder instance (ensuring correct delete across DLL boundaries) ">destroy()</a>: destroys **ppTextureDecoder and additionally sets *ppTextureDecoder to NULL. <br /></td></tr>
<tr class="separator:a579f64f7f682e58d750a9502631e1036"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for simple extraction of texture resources (and associated rendering semantic) from AxF representations, for instance in order to use them in a custom renderer. This is useful in particular when the usage of <a class="el" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html" title="Decodes AxF representations on the CPU. ">CPUDecoder</a> for rendering is not feasible for a certain target application. This is especially true for GPU-based renderers but also for some CPU-based engines which rely on special techniques or data-structures optimized for parallelization.</p>
<p>Basic usage: </p><div class="fragment"><div class="line">AXF_REPRESENTATION_HANDLE h_axf_rep = <a class="code" href="namespaceaxf_1_1decoding.html#a36755ec273d115909eefb03268beec0c">axfGetPreferredRepresentation</a>( h_axf_file );</div><div class="line">CPUDecoder* pcl_decoder = <a class="code" href="classaxf_1_1decoding_1_1_c_p_u_decoder.html#acb81a71521ab469e5c85b4e81c07f7f6">CPUDecoder::create</a>( h_axf_rep );</div><div class="line">...</div><div class="line">TextureDecoder* pcl_tex_decoder = <a class="code" href="classaxf_1_1decoding_1_1_texture_decoder.html#a135b6c876ace1227a8e7dacac70ed09b">TextureDecoder::create</a>( h_axf_rep, pcl_decoder, <a class="code" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546a5a8c2e03f44e80140d7ed828408477c5">ORIGIN_TOPLEFT</a>, <a class="code" href="namespaceaxf_1_1decoding.html#a16895524f5dc85432f79872337ca0659af8ce4fda422da8997469be1a787269a9">ID_DEFAULT</a> );</div><div class="line">...</div><div class="line">if ( pcl_tex_decoder-&gt;getNumTextures() &gt; 0) {</div><div class="line">     <span class="keywordtype">char</span> s_tex_name[255];</div><div class="line">     pcl_tex_decoder-&gt;getTextureName( 0, s_tex_name, 255 );</div><div class="line">     <span class="keywordflow">if</span> ( <span class="stringliteral">&quot;diffuse&quot;</span> == s_tex_name ) {</div><div class="line">         <span class="keywordtype">int</span> i_width, i_height, i_depth, i_channels, i_datatype_src;</div><div class="line">         pcl_tex_decoder-&gt;getTextureSize( 0, 0, i_width, i_height, i_depth, i_channels, i_datatype_src );</div><div class="line">         <span class="keywordtype">float</span>* pcl_texture_buffer = createTextureBuffer&lt;float&gt;( i_width, i_height, i_depth, i_channels );</div><div class="line">         pcl_tex_decoder-&gt;getTextureData( 0, 0, <a class="code" href="namespaceaxf_1_1decoding.html#ac173a11f232e8c93eef53a4e5f071fa2a38f03a642533120ec9df83c0aa7ca27d">TEXTURE_TYPE_FLOAT</a>, pcl_texture_buffer )</div><div class="line">         ...</div><div class="line">     }</div><div class="line">     ...</div><div class="line"> }</div><div class="line"> ...</div><div class="line"> pcl_tex_decoder-&gt;destroy();</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="_texture_decoder_8h_source.html#l00078">78</a> of file <a class="el" href="_texture_decoder_8h_source.html">TextureDecoder.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a92be5164c0b3d7900c5bd460e0b40124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92be5164c0b3d7900c5bd460e0b40124">&#9670;&nbsp;</a></span>getWidthPixel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int axf::decoding::TextureDecoder::getWidthPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Maximum width in pixels of all texture resources in this representation that are parameterized over the spatial U,V axes</dd></dl>
<p>Note that the width of the individual textures (which can be queried using <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a54db6153d8b9058a1794bfadb26e5e2f" title="Returns the size of the given texture in pixels, the number of channels, and the texture type in whic...">getTextureSize()</a>) may vary from this maximum width. This enables SVBRDF representations to store different BRDF parameters in different resolutions, for instance in order to reduce the overall memory consumption of the representation (cf. <a class="el" href="page4.html">Performance Guidelines</a>).</p>
<p>A potential use case of this function (along with <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#ac276a6c2dd013e7a9226b857c7940d89" title="Returns the (maximum) physical width in millimeters of all texture resources in this representation t...">getWidthMM()</a>) is for estimating the overall spatial resolution of the representation along the U axis. </p>

</div>
</div>
<a id="ab37f57a2aedf7d331e4af38e87e0dd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37f57a2aedf7d331e4af38e87e0dd6a">&#9670;&nbsp;</a></span>getHeightPixel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int axf::decoding::TextureDecoder::getHeightPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Maximum height in pixels of all texture resources in this representation that are parameterized over the spatial U,V axes</dd></dl>
<p>Note that the height of the individual textures (which can be queried using <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a54db6153d8b9058a1794bfadb26e5e2f" title="Returns the size of the given texture in pixels, the number of channels, and the texture type in whic...">getTextureSize()</a>) may vary from this maximum height. This enables SVBRDF representations to store different BRDF parameters in different resolutions, for instance in order to reduce the overall memory consumption of the representation (cf. <a class="el" href="page4.html">Performance Guidelines</a>).</p>
<p>A potential use case of this function (along with <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#ab85ae89e4f10b8a632b4a5139bb1ea05" title="Returns the (maximum) physical height in millimeters of all texture resources in this representation ...">getHeightMM()</a>) is for estimating the overall spatial resolution of the representation along the V axis. </p>

</div>
</div>
<a id="ac276a6c2dd013e7a9226b857c7940d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac276a6c2dd013e7a9226b857c7940d89">&#9670;&nbsp;</a></span>getWidthMM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float axf::decoding::TextureDecoder::getWidthMM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Maximum physical width in millimeters of all texture resources in this representation that are parameterized over the spatial U,V axes</dd></dl>
<p>Note that while (unedited) measured materials always have a unique physical size, which is shared by all (spatially parameterized) textures in the material representation, AxF nonetheless allows that the individual textures might have varying physical sizes (which can be queried using <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a49334f80849aa6ff85d14ed6dc7eb5aa" title="Returns the physical width and height (corresponding to the spatial U,V axes) of the given texture in...">getTextureSizeMM()</a>). In case of SVBRDF representations, the latter makes sense in context of tiled materials only (as it describes the physical size of a single tiled pattern for the respective resource, and thus indirectly its tiling frequency). While we don't encourage the creation of SVBRDF representations with varying physical sizes per resource in general, this feature was introduced to allow for more artistic freedom when hand-editing a material. </p>

</div>
</div>
<a id="ab85ae89e4f10b8a632b4a5139bb1ea05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85ae89e4f10b8a632b4a5139bb1ea05">&#9670;&nbsp;</a></span>getHeightMM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float axf::decoding::TextureDecoder::getHeightMM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Maximum physical height in millimeters of all texture resources in this representation that are parameterized over the spatial U,V axes</dd></dl>
<p>Note that while (unedited) measured materials always have a unique physical size, which is shared by all (spatially parameterized) textures in the material representation, AxF nonetheless allows that the individual textures might have varying physical sizes (which can be queried using <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a49334f80849aa6ff85d14ed6dc7eb5aa" title="Returns the physical width and height (corresponding to the spatial U,V axes) of the given texture in...">getTextureSizeMM()</a>). In case of SVBRDF representations, the latter makes sense in context of tiled materials only (as it describes the physical size of a single tiled pattern for the respective resource, and thus indirectly its tiling frequency). While we don't encourage the creation of SVBRDF representations with varying physical sizes per resource in general, this feature was introduced to allow for more artistic freedom when hand-editing a material. </p>

</div>
</div>
<a id="a828db702ab229008a3dbbe49067506a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828db702ab229008a3dbbe49067506a8">&#9670;&nbsp;</a></span>getTextureData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool axf::decoding::TextureDecoder::getTextureData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iMipLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iTargetTextureType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the content of the given texture / mip-map level as float array (iTargetTextureType=TEXTURE_TYPE_FLOAT) or half-float array (iTargetTextureType=TEXTURE_TYPE_HALF) into a user-allocated buffer, whose size must be iWidth*iHeight*iDepth*iChannels*sizeof(iTargetTextureType) (where iWidth,iHeight,iDepth,iChannels are the values returned by <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a54db6153d8b9058a1794bfadb26e5e2f" title="Returns the size of the given texture in pixels, the number of channels, and the texture type in whic...">getTextureSize()</a>, and sizeof(iTargetTextureType) is 4 or 2 bytes for TEXTURE_TYPE_FLOAT or TEXTURE_TYPE_HALF, respectively); iTargetTextureType may differ from iStorageTextureType returned by <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a54db6153d8b9058a1794bfadb26e5e2f" title="Returns the size of the given texture in pixels, the number of channels, and the texture type in whic...">getTextureSize()</a> </p>

</div>
</div>
<a id="a135b6c876ace1227a8e7dacac70ed09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135b6c876ace1227a8e7dacac70ed09b">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html">TextureDecoder</a>* axf::decoding::TextureDecoder::create </td>
          <td>(</td>
          <td class="paramtype">AXF_REPRESENTATION_HANDLE&#160;</td>
          <td class="paramname"><em>hAxFRepresentation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sTargetColorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iTextureOrigin</em> = <code><a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546af81cf674c1146c260fd907f0794d252b">ORIGIN_BOTTOMLEFT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iTargetSystemID</em> = <code><a class="el" href="namespaceaxf_1_1decoding.html#a16895524f5dc85432f79872337ca0659af8ce4fda422da8997469be1a787269a9">ID_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hAxFRepresentation</td><td>Valid handle to AxF representation (cf. <a class="el" href="namespaceaxf_1_1decoding.html#a3c04510b187bd2d96d58d4f762e5c3b9" title="Return a handle to a specific representation of an AxF material. ">axfGetRepresentation()</a> etc.) </td></tr>
    <tr><td class="paramname">sTargetColorSpace</td><td>Trichromatic target color space (see below) </td></tr>
    <tr><td class="paramname">iTextureOrigin</td><td>cf. enum <a class="el" href="namespaceaxf_1_1decoding.html#a81aa4ecc3994ce4d0519d103b192c546" title="Spatially varying textures need to have a defined embedding into 3D. ">ETextureOrigin</a> </td></tr>
    <tr><td class="paramname">iTargetSystemID</td><td>Deprecated - use ID_DEFAULT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html" title="Decodes texture resources from AxF representations. ">TextureDecoder</a> instance. Needs to be deallocated using <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#af929ea96157764df4049c295dcc8d687" title="Destroy TextureDecoder instance (ensuring correct delete across DLL boundaries) ">destroy()</a>.</dd></dl>
<p>sTargetColorSpace must be one of:</p><ul>
<li>AXF_COLORSPACE_CIE_1931_XYZ ("XYZ"): the CIE 1931 XYZ color space</li>
<li>AXF_COLORSPACE_LINEAR_SRGB_E ("sRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the sRGB color space (IEC 61966-2-1), but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
<li>AXF_COLORSPACE_LINEAR_ADOBE_RGB_E ("AdobeRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the Adobe RGB (1988) color space, but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
<li>AXF_COLORSPACE_LINEAR_ADOBE_WIDEGAMUT_RGB_E ("WideGamutRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the Adobe Wide-Gamut RGB color space, but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
<li>AXF_COLORSPACE_LINEAR_PROPHOTO_RGB_E ("ProPhotoRGB,E"): a <em>linear</em> color space with primary chromaticities matching those of the ProPhoto RGB color space, but - similarly to CIE XYZ - with equal-energy white point [i.e. the unity reflectance spectrum is mapped to RGB values (1 1 1)]</li>
</ul>
<p>Note that all of the above options represent linear, trichromatic color spaces for the 2 degree standard observer. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 18 2018 00:04:38 for AxF Decoding SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
