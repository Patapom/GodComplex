<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AxF Decoding SDK: SVBRDF Representation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="AxF-SDK-Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AxF Decoding SDK
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">Decoding AxF representations</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">AxF Decoding SDK</a></li><li class="navelem"><a class="el" href="pages1-3.html">AxF Representations</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">SVBRDF Representation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#svbrdf_sec01">Preliminaries</a><ul><li class="level2"><a href="#svbrdf_subsec00">Digital material modeling with BRDFs</a><ul><li class="level3"><a href="#svbrbf_modeling_para01">Lambert diffuse model</a></li>
<li class="level3"><a href="#svbrbf_modeling_para02">Ward specular model</a></li>
<li class="level3"><a href="#svbrbf_modeling_para03">Blinn-Phong (Ashikhmin-Shirley) specular model</a></li>
<li class="level3"><a href="#svbrbf_modeling_para04">Cook-Torrance specular model</a></li>
<li class="level3"><a href="#svbrdf_modeling_para05">GGX specular model</a></li>
<li class="level3"><a href="#svbrdf_modeling_fresnel">Fresnel term</a></li>
</ul>
</li>
<li class="level2"><a href="#svbrdf_subsec01">Remarks</a></li>
<li class="level2"><a href="#svbrdf_subsec02">Spatially varying BRDF models</a></li>
<li class="level2"><a href="#svbrdf_subsec03">Coated SVBRDFs</a></li>
</ul>
</li>
<li class="level1"><a href="#svbrdf_sec02">SVBRDFs in AxF</a><ul><li class="level2"><a href="#svbrdf_sec02_01">AxF Version 1.0</a></li>
<li class="level2"><a href="#svbrdf_sec02_02">AxF Version 1.1</a></li>
<li class="level2"><a href="#svbrdf_sec02_03">AxF Version 1.3</a></li>
<li class="level2"><a href="#svbrdf_sec02_04">AxF Version 1.4</a></li>
<li class="level2"><a href="#svbrdf_sec02_05">AxF Version 1.5</a></li>
</ul>
</li>
<li class="level1"><a href="#svbrdf_sec03">SVRDF Implementation Guideline</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="svbrdf_sec01"></a>
Preliminaries</h1>
<h2><a class="anchor" id="svbrdf_subsec00"></a>
Digital material modeling with BRDFs</h2>
<p>The spatial varying BRDF (SVBRDF) and its variants as of now can be considered the primarily used representations for materials in Computer Graphics applications. The classic definition</p>
<p class="formulaDsp">
\[ f(\omega_i,\omega_o)=\frac{dL_o(\omega_o)}{dE_i(\omega_i)}=\frac{dL_o(\omega_o)}{dL_i(\omega_i)cos\theta_i d\omega_i} \]
</p>
<p>defines the BRDF as the ratio of differential outgoing radiance to differential incoming irradiance. This 4D function is usually modeled by parametric functions mimicking the behavior of real-world BRDFs in a more or less physically correct way by defining some parameter vector \(\mathbf{P}\):</p>
<p class="formulaDsp">
\[ f_\mathbf{P}(\omega_i,\omega_o) = \hat{f}(\mathbf{P};\omega_i,\omega_o) \]
</p>
<p>In order to bring the mathematical notation closer to implementation we slightly change the notation of directions compared to classic Computer Graphics as above and define the following symbols:</p><ul>
<li>\(\mathbf{i} = \) normalized incoming direction vector given in local tangent space tnb</li>
<li>\(\mathbf{o} = \) normalized outgoing direction vector given in local tangent space tnb</li>
<li>\(\mathbf{h} = \) normalized halfangle vector \(\mathbf{h}=\frac{\mathbf{i}+\mathbf{o}}{|\mathbf{i}+\mathbf{o}|}\)</li>
<li>\(\mathbf{h&#39;} = \) the non-normalized halfangle vector \(\mathbf{h&#39;}=\mathbf{i}+\mathbf{o}\)</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>By defining the directions in local tangent space we can omit an explicit normal vector in the equations because the normal vector will always be the vector \(\textbf{n}=(0,0,1)^T\) and correspondingly the tangent and bi-tangent vectors also do not need to appear in the equations. To apply these equations in practice a transformation from world- or object-space respectively into the local tangent space (which might be modified per pixel using normal mapping) has to be used.</dd>
<dd>
For anisotropic models not only the orientation of the local tangent space plane but also its rotation around the normal matters. E.g. when an anisotropic SVBRDF model is used to fit the measurements of a brushed metal, the fit should also capture the variations in the brush direction which means the orientation needs to vary per pixel. AxF supports such materials by storing a rotation map texture which can be thought of as an extension of the classic normal map by not only varying the orientation of the local tangent space but also its rotation.</dd></dl>
<p>By default a BRDF in the AxF Decoding SDK is an additive combination of a diffuse model representing the amount of light that is scattered in the material and after multiple scattering events leaves the surface in a random direction with uniform distribution and a specular model which represents light scattered on the surface and reflected most likely into the direction of the mirror direction (by assuming the surface can be modeled by a distribution of so-called microfacets): </p><p class="formulaDsp">
\[ f(\mathbf{i},\mathbf{o}) = f_d(\mathbf{i},\mathbf{o}; d) + f_s(\mathbf{i},\mathbf{o}; s,p_s,...) \]
</p>
<p> where \(d\) is the diffuse color (albedo of the diffuse term), \(s\) the specular color (albedo/weight of the specular term), and \(p_s,...\) denotes the set of model-dependent specular parameters detailed below.</p>
<p>The AxF Decoding SDK supports several BRDF models as listed in the following paragraphs. If not otherwise indicated we present the more general anisotropic variant of the model.</p>
<h3><a class="anchor" id="svbrbf_modeling_para01"></a>
Lambert diffuse model</h3>
<p class="formulaDsp">
\[ f_d(\mathbf{i},\mathbf{o}; d) = \frac{d}{\pi}, \]
</p>
<p> a constant BRDF with a single albedo parameter \(d\).</p>
<h3><a class="anchor" id="svbrbf_modeling_para02"></a>
Ward specular model</h3>
<p class="formulaDsp">
\[ f^{Ward}_s (\mathbf{i},\mathbf{o}; s,\alpha,\beta) = s \frac{1}{\pi\alpha\beta}N_{\left&lt;variant\right&gt;}e^{-\frac{1}{h^2_z}\left(\frac{h^2_x}{\alpha^2}+\frac{h^2_y}{\beta^2}\right)}, \]
</p>
<p> with \(\alpha, \beta\) being the standard deviations of the elliptical Gaussian along the principal directions (typically called <em>roughness</em> parameters). The following variants for the normalization term \(N_{\left&lt;variant\right&gt;}\) are supported:</p><ul>
<li>\(N_{Ward92}=\frac{1}{4\,\sqrt{i_z o_z}}\), <a class="el" href="citelist.html#CITEREF_Ward:1992">[10]</a></li>
<li>\(N_{Duer06}=\frac{1}{4\,i_z o_z}\), <a href="http://homepage.uibk.ac.at/~c70240/abstract_ward_model.pdf">Duer 2004</a></li>
<li>\(N_{GM2010}=\frac{1}{4\,\left&lt;\mathbf{i},\mathbf{h}\right&gt;^2 h^4_z}\), <a href="https://doi.org/10.1111/j.1467-8659.2010.01735.x">Geisler-Moroder 2010</a></li>
</ul>
<p>Using the <b>non-normalized</b> halfangle vector \(\mathbf{h&#39;}\), the third variant of the normalization term can <em>equivalently</em> be written as: (<a href="http://www.radiance-online.org/community/workshops/2010-freiburg/PDF/geisler-moroder_duer_thetmeyer_RW2010.pdf">Geisler-Moroder 2010b</a>):</p><ul>
<li>\(N_{GM2010}=\frac{\left&lt;\mathbf{h&#39;},\mathbf{h&#39;}\right&gt;}{{h&#39;_z}^4}\)</li>
</ul>
<p>and thus the full specular model as: </p><p class="formulaDsp">
\[ f^{{Ward}_{GM2010}}_s (\mathbf{i},\mathbf{o}; s,\alpha,\beta) = s \frac{1}{\pi\alpha\beta}\frac{\left&lt;\mathbf{h&#39;},\mathbf{h&#39;}\right&gt;}{{h&#39;_z}^4}e^{-\frac{1}{{h&#39;_z}^2}\left(\frac{{h&#39;_x}^2}{\alpha^2}+\frac{{h&#39;_y}^2}{\beta^2}\right)}, \]
</p>
<p> This variant of the Ward model by Geisler-Moroder has shown to be superior to the previous variants and is thus the standard BRDF model for AxF representations of version 1.0 to 1.4.</p>
<p>Starting from AxF version 1.1, AxF further extends the Ward model by an (optional) Fresnel term as follows: </p><p class="formulaDsp">
\[ {f^{Ward}_s}&#39; (\mathbf{i},\mathbf{o}; s,\alpha,\beta,F_0) = f^{Ward}_s (\mathbf{i},\mathbf{o}; s,\alpha,\beta) F(\mathbf{h},\mathbf{o}; F_0) \]
</p>
<p> For the Fresnel term \(F\) we use Schlick's approximation, see <a class="el" href="page1.html#svbrdf_modeling_fresnel">Fresnel term</a>.</p>
<p>The existence of the Fresnel term in an AxF representation can be queried via <a class="el" href="namespaceaxf_1_1decoding.html#a9260fc8b8fba5f1cc449f9557ed4e199" title="Retrieve a string and a few flags identifying the variant of the specular model represented in the Ax...">axf::decoding::axfGetSvbrdfSpecularModelVariant()</a>. Note that \(f^{Ward}_s = {f^{Ward}_s}&#39;\) with \(F_0 = 1\), so by defaulting \(F_0\) to 1 for Ward representations without Fresnel term, it is possible to evaluate \({f^{Ward}_s}&#39;\) for all Ward representations.</p>
<h3><a class="anchor" id="svbrbf_modeling_para03"></a>
Blinn-Phong (Ashikhmin-Shirley) specular model</h3>
<p>Anisotropic variant of the Blinn-Phong model as proposed by Ashikhmin and Shirley: </p><p class="formulaDsp">
\[ f^{AS}_s (\mathbf{i},\mathbf{o}; s,n_u,n_v) = s\frac{\sqrt{(n_u+1)(n_v+1)}}{8\pi}\frac{h_z^{\frac{n_uh_x^2+n_vn_y^2}{1-h_z^2}}}{\left&lt;\mathbf{h},\mathbf{o}\right&gt;\max(i_z,o_z)} \]
</p>
<p> It turned out in practice that fitting parameters \(n&#39;_u, n&#39;_v\) with \(n_{u,v} = 2^{n&#39;_{u,v}} \) leads to more stable fitting. Therefore we fit and store those modified parameters instead of the classic exponents.</p>
<p>For the isotropic variant \(n_u=n_v\) the SDK supports also the classic Blinn-Phong model extended by a widely used normalization term: \( f^{Blinn}_{s}(\mathbf{i},\mathbf{o}; s,n) = s\frac{n+2}{8\pi}h_z^n \)</p>
<h3><a class="anchor" id="svbrbf_modeling_para04"></a>
Cook-Torrance specular model</h3>
<p>Isotropic variant: </p><p class="formulaDsp">
\[ f^{CT}_s (\mathbf{i},\mathbf{o}; s,\alpha,F_0) = \frac{s}{\pi}\frac{D(\mathbf{h}; \alpha)F(\mathbf{h},\mathbf{o}; F_0)G(\mathbf{i},\mathbf{o})}{i_z o_z}, \]
</p>
<p> where \(D\) is the microfacet distribution, \(F\) the Fresnel term and \(G\) is the geometry term.</p>
<p>For the microfacet distribution we use the Beckmann distribution: </p><p class="formulaDsp">
\[ D(\mathbf{h}; \alpha) = \frac{1}{\alpha^2h_z^4}e^{\frac{h_z^2-1}{h_z^2\alpha^2}} \]
</p>
<p> For the Fresnel term we use Schlick's approximation, see <a class="el" href="page1.html#svbrdf_modeling_fresnel">Fresnel term</a>.</p>
<p>The geometry term is the classical one from Cook-Torrance: </p><p class="formulaDsp">
\[ G(\mathbf{i},\mathbf{o}) = \min\left(1,\frac{2h_zo_z}{\left&lt;\mathbf{h},\mathbf{o}\right&gt;},\frac{2h_zi_z}{\left&lt;\mathbf{h},\mathbf{o}\right&gt;}\right) \]
</p>
 <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Document anisotropic variant of Cook-Torrance</dd></dl>
<h3><a class="anchor" id="svbrdf_modeling_para05"></a>
GGX specular model</h3>
<p>Isotropic variant: </p><p class="formulaDsp">
\[ f^{GGX}_s (\mathbf{i},\mathbf{o}; s,\alpha,F_0) = \frac{s}{\pi}\frac{D^{TR}(\mathbf{h}; \alpha)F(\mathbf{h},\mathbf{o}; F_0)G^{Smith}(\mathbf{i},\mathbf{o}; \alpha)}{i_z o_z}, \]
</p>
<p> where \(D^{TR}\) is the Trowbridge-Reitz microfacet distribution, \(F\) the Fresnel term and \(G^{Smith}\) is the Smith geometry term.</p>
<p>The Trowbridge-Reitz microfacet distribution is defined as: </p><p class="formulaDsp">
\[ D^{TR}(\mathbf{h}; \alpha) = \frac{1}{\alpha^2 \left&lt;\mathbf{n},\mathbf{h}\right&gt;^4 \left(1 + \frac{1 - \left&lt;\mathbf{n},\mathbf{h}\right&gt;^2}{\alpha^2 \left&lt;\mathbf{n},\mathbf{h}\right&gt;^2}\right)^2} = \frac{\alpha^2}{\left(\left&lt;\mathbf{n},\mathbf{h}\right&gt;^2(\alpha^2-1)+1\right)^2} \]
</p>
<p> For the Fresnel term we use Schlick's approximation, see <a class="el" href="page1.html#svbrdf_modeling_fresnel">Fresnel term</a>.</p>
<p>The Smith geometry term is defined in terms of a separate function \(G_1\): </p><p class="formulaDsp">
\[ G^{Smith}(\mathbf{i},\mathbf{o}; \alpha) = G_1(\mathbf{i},\mathbf{h}; \alpha) G_1(\mathbf{o},\mathbf{h}; \alpha) \]
</p>
 <p class="formulaDsp">
\[ G_1(\mathbf{v},\mathbf{h}; \alpha) = \chi^+(\left&lt;\mathbf{v},\mathbf{h}\right&gt;) \frac{2 \left&lt;\mathbf{n},\mathbf{v}\right&gt;}{\left&lt;\mathbf{n},\mathbf{v}\right&gt; + \sqrt{\alpha^2 + (1-\alpha^2)\left&lt;\mathbf{n},\mathbf{v}\right&gt;}} \]
</p>
<p> where \(\chi^+(x)=\begin{cases}1 &amp; x&gt;0\\ 0 &amp; \textrm{otherwise}\end{cases}\). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Document anisotropic variant of GGX and add references</dd></dl>
<h3><a class="anchor" id="svbrdf_modeling_fresnel"></a>
Fresnel term</h3>
<p>Currently all AxF representations that include a Fresnel term use Schlick's approximation: </p><p class="formulaDsp">
\[ F(\mathbf{h},\mathbf{o}; F_0) = F_0 + (1-F_0)(1-\left&lt;\mathbf{h},\mathbf{o}\right&gt;)^5 \]
</p>
<h2><a class="anchor" id="svbrdf_subsec01"></a>
Remarks</h2>
<p>In order to retrieve the actual specular model and its variant used by an AxF representation, use <a class="el" href="namespaceaxf_1_1decoding.html#a736a18d854555b7a29eb38dade7f538c" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the specular component of the BRDF model. ">axf::decoding::axfGetSvbrdfSpecularModelRepresentation()</a> and <a class="el" href="namespaceaxf_1_1decoding.html#a9260fc8b8fba5f1cc449f9557ed4e199" title="Retrieve a string and a few flags identifying the variant of the specular model represented in the Ax...">axf::decoding::axfGetSvbrdfSpecularModelVariant()</a>, respectively. For more information see <a class="el" href="page1.html#svbrdf_sec02">SVBRDFs in AxF</a>.</p>
<h2><a class="anchor" id="svbrdf_subsec02"></a>
Spatially varying BRDF models</h2>
<p>A single BRDF describes only perfectly homogeneous materials which do not exist in reality. Real-world surfaces usually exhibit spatial variation like textural color patterns, scratches, dust, hair etc. These spatial variations are modeled in Computer Graphics by two main approaches: either procedurally using a some calculation rule or by image textures. Since we are dealing with measured data our models capture spatial variation using image textures where each texel holds some parameters of a given BRDF model. </p><div class="image">
<img src="brdf_blob.png" alt="brdf_blob.png"/>
<div class="caption">
Homogenous glossy plastic-like material described by a single BRDF</div></div>
 Over the years the the parametric SVBRDF model has become the de-facto standard in current computer graphics applications: </p><p class="formulaDsp">
\[ f(\mathbf{x},\mathbf{i},\mathbf{o}) = f_{d,T_{N}(\mathbf{x})} (\mathbf{i},\mathbf{o}; T_d(\mathbf{x})) + f_{s,T_{N}(\mathbf{x})} (\mathbf{i},\mathbf{o}; T_s(\mathbf{x}),T_{p_s}(\mathbf{x}),...) \]
</p>
<p> The texture operator \(T(\mathbf{x})\) is typically a 2D table of values of various types indexed by the texture coordinate \(\mathbf{x}\). \(T_{N}(\mathbf{x})\) is the <em>normal map</em> which is used to vary the local coordinate system (of \(\mathbf{i},\mathbf{o}\)) in order to simulate a bumpy surface. \(T_d(\mathbf{x})\) and \(T_s(\mathbf{x})\) contain color values (typically trichromatic RGB values) which are used as weights for the diffuse and the specular BRDF part. Last but not least \(T_{p_s}(\mathbf{x}),...\) are the maps of model-dependent specular parameters (e.g. roughness map and Fresnel \(F_0\) map).</p>
<p>These four different textures are the classic SVBRDF model textures in case of an isotropic model without Fresnel term:</p><ul>
<li>diffuse color, \(T_{d}(\mathbf{x})\)</li>
<li>specular color, \(T_{s}(\mathbf{x})\)</li>
<li>normal, \(T_{N}(\mathbf{x})\)</li>
<li>roughness/glossiness/specularity, \(T_{p_s}(\mathbf{x})\)</li>
</ul>
<div class="image">
<img src="svbrdf_layers_leather.png" alt="svbrdf_layers_leather.png"/>
<div class="caption">
The standard four textures diffuse, specular, normal, roughness of an SVBRDF model for the isotropic Ward BRDF (leather material)</div></div>
<div class="image">
<img src="svbrdf_blob.png" alt="svbrdf_blob.png"/>
<div class="caption">
Measured leather material represented by a spatially varying BRDF</div></div>
<p>In order to add an SVBRDF model to a rendering application it is required to implement the texture access operator \(T(\mathbf{x})\) and the diffuse and specular BRDF models \(f_d, f_s\).</p>
<h2><a class="anchor" id="svbrdf_subsec03"></a>
Coated SVBRDFs</h2>
<p>An important material class are materials made of different semi-transparent layers. For the sake of simplicity we restrict Baseline AxF to materials with a single <em>clear coat</em> on top of an opaque base material: </p><div class="image">
<img src="FresnelLayer.png" alt="FresnelLayer.png"/>
<div class="caption">
Base SVBRDF material covered by a classical transparent Fresnel BSDF layer.</div></div>
<p>While these materials occur surprisingly often in industry they can still be measured and modeled with acceptable additional effort compared to standard SVBRDFs. In particular it is assumed that the coating is completely transparent (no absorption and scattering despite at the layer boundaries), infinitesimal thin (refracted rays from the coating hit the lower layer at the same point) and solely defined by its (spatially varying) index of refraction and an (optional) normal map which allows to model mesoscopic effects like the <em>Orange Peel</em>-effect. According to <a class="el" href="citelist.html#CITEREF_Weidlich_Wilkie_2007">[11]</a> we evaluate the two layers \(f_c\) and \(f_b\) (coating and base) as follows with \(\bar{\mathbf{i}}=\textbf{refract}(\mathbf{i},n_{cc},n_{air})\) denoting the refracted ray (and omitting spatial variation): </p><p class="formulaDsp">
\[ f(\mathbf{i},\mathbf{o}) = f_{c}(\mathbf{i},\mathbf{o}) + T_{air\rightarrow c}f_b(\overline{\mathbf{i}},\overline{\mathbf{o}})\cdot a_c \cdot t_c \]
</p>
<p> We neglect absorption ( \(a_c = 1\)) and for the time being also don't consider the effect of total internal reflection which simplifies \(t_c\) to \(T_{c\rightarrow air} = 1-F(\mathbf{o})\). As a consequence energy reflected back to the base is formally lost but please keep in mind that AxF stores models fitted to real data which means that this energy will actually be "baked" into the base SVBRDF \(f_b\) during fitting. Hence \(f_b\) will not fully model the true underlying BRDF (which will only become apparent if the base material is rendered without the coating). In fact, this general strategy is well inline with the whole concept of using an SVBRDF for modeling a real-world material: interaction i.e. (sub-surface) scattering between different surface points is not factored out but baked into the per-pixel BRDF.</p>
<p>Finally we arrive at the following formula for our coated BRDF: </p><p class="formulaDsp">
\[ f(\mathbf{i},\mathbf{o}) = f_c(\mathbf{i},\mathbf{o}) + (1-F(\mathbf{i}))\cdot f_b(\overline{\mathbf{i}},\overline{\mathbf{o}})\cdot (1-F(\mathbf{o})) \]
</p>
<p> whereas \(f_c(\mathbf{i},\mathbf{o}) = F(\mathbf{i})\cdot \delta(reflect(\mathbf{i})-\mathbf{o})\) is the perfect reflection. In practice, Schlick's Fresnel approximation can be used here, which means the additional effort for evaluating such a coated SVBRDF is a perfect reflection, two (Schlick) Fresnel terms and two refractions.</p>
<p>If the refraction of the in- and outgoing rays cannot be afforded AxF also supports to define a non-refractive clearcoat layer, i.e. the directions for evaluating the base layer are not refracted. This coating property can be determined by querying the <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html" title="Decodes texture resources from AxF representations. ">axf::decoding::TextureDecoder</a> property <em>cc_no_refraction</em>). Similar to the effect of the total internal reflection the refraction will then be "baked" into the SVBRDF model. Please note, that not considering the <em>cc_no_refraction</em> option (e.g. by refracting rays during rendering although the model has been fitted without refraction and vice versa) will lead to wrong results. </p><div class="image">
<img src="coated_svbrdf_blob.png" alt="coated_svbrdf_blob.png"/>
<div class="caption">
Measured coated leather material with orange peel effect.</div></div>
<h1><a class="anchor" id="svbrdf_sec02"></a>
SVBRDFs in AxF</h1>
<p>In AxF, SVBRDF representions are of representation class <em>SVBRDF</em> (see <a class="el" href="namespaceaxf_1_1decoding.html#a57cd171d9aa6a6c53e0ddceb8dd06898" title="Retrieve the RepresentationClass, which classifies the representation as SVBRDF, CarPaint, etc. ">axf::decoding::axfGetRepresentationClass()</a>), which is represented internally by a hierarchy of AxF nodes. The basic building blocks like the diffuse or specular model correspond to sub-nodes in this hierarchy (which can be obtained via <a class="el" href="namespaceaxf_1_1decoding.html#a5dbc9210d9c3801de81fb22d4cd9ed43" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the diffuse component of the BRDF model. ">axf::decoding::axfGetSvbrdfDiffuseModelRepresentation()</a> and <a class="el" href="namespaceaxf_1_1decoding.html#a736a18d854555b7a29eb38dade7f538c" title="Given an AxF representation (of representation class SVBRDF, CarPaint, or CarPaint2), retrieve the child representation for the specular component of the BRDF model. ">axf::decoding::axfGetSvbrdfSpecularModelRepresentation()</a>). The default building blocks are a diffuse model, a specular model, and optionally (depending on the AxF version) a clear coat model, transparency and displacement models and finally a sub-surface scattering model (experimental, will be supported by future versions). The respective type keys for the corresponding AxF nodes are as follows (cf. <a class="el" href="namespaceaxf_1_1decoding.html#a544463086d0f705d06909be912f51ce2" title="Retrieve the TypeKey from the given representation node. ">axf::decoding::axfGetRepresentationTypeKey()</a>):</p><ul>
<li>Diffuse Model<ul>
<li>com.xrite.LambertDiffuseModel</li>
</ul>
</li>
<li>Specular Model<ul>
<li>com.xrite.WardSpecularModel</li>
<li>com.xrite.PhongSpecularModel</li>
<li>com.xrite.BlinnPhongSpecularModel</li>
<li>com.xrite.CookTorranceSpecularModel</li>
<li>com.xrite.GGXSpecularModel (for version &gt;= 1.5)</li>
</ul>
</li>
<li>Measured Clear Coat Model (for version &gt;= 1.1)<ul>
<li>com.xrite.ClearCoatFilter</li>
</ul>
</li>
<li>Measured Transparency Model (for version &gt;= 1.4)<ul>
<li>com.xrite.TransparencyFilter</li>
</ul>
</li>
<li>Measured Displacement Model (for version &gt;= 1.4)<ul>
<li>com.xrite.DisplacementFilter</li>
</ul>
</li>
<li>Subsurface Model (for version &gt;= t.b.d.)<ul>
<li>com.xrite.SubSurfaceScatteringModel</li>
</ul>
</li>
</ul>
<p>Please note that in contrast to prior versions of the SDK, the type key of the representation's root node shouldn't be queried anymore (since it might differ for different SVBRDF variants, but isn't representative for the full SVBRDF description).</p>
<p>In the following we will give short overview on the mandatory specifications of the SVBRDF representation for the different AxF versions. See also <a class="el" href="namespaceaxf_1_1decoding.html#ac3229499828c83f0c934e1c865a452d3" title="Check if representation fits into the given compatibility profile. ">axf::decoding::axfCheckRepresentationCompatibilityProfile()</a>.</p>
<p>Please note, that the subsurface scattering model is not fully specified yet and planned for future versions.</p>
<h2><a class="anchor" id="svbrdf_sec02_01"></a>
AxF Version 1.0</h2>
<p>This version defines AxF's basic SVBRDF model: Lambert diffuse and Ward specular model with Geisler-Moroder normalization term (cf. <a class="el" href="page1.html#svbrbf_modeling_para02">Ward specular model</a>).</p>
<p>A typical implementation of the (isotropic) specular part of this model using GLSL looks as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> dotNLWeightedSpecularTerm(in viewdata vdata, in vec3 L, <span class="keywordtype">float</span> dotNL)</div><div class="line">{        </div><div class="line">        <span class="comment">//-- isotropic Ward-based model: --</span></div><div class="line">        vec3  H = L + vdata.V;         <span class="comment">//halfway vector, not normalized on purpose</span></div><div class="line">        <span class="keywordtype">float</span> dotNH = H.z;</div><div class="line">        <span class="keywordflow">if</span> (dotNH &lt;= 0.0)</div><div class="line">            <span class="keywordflow">return</span> 0.0;</div><div class="line">        <span class="keywordtype">float</span> dotNH_sqr = dotNH * dotNH;</div><div class="line">        <span class="keywordtype">float</span> dotHH = dot(H, H);</div><div class="line">        <span class="keywordtype">float</span> F = 1.0;</div><div class="line">        <span class="keywordtype">float</span> invVar = 1.0 / (vdata.speclobe * vdata.speclobe);</div><div class="line">        <span class="keywordtype">float</span> expval = exp((1.0 - dotHH / dotNH_sqr) * invVar);    </div><div class="line">        <span class="keywordflow">if</span> (expval == 0.0)</div><div class="line">            <span class="keywordflow">return</span> 0.0;</div><div class="line">        <span class="keywordflow">return</span> (M_1_PI * dotNL * dotHH * F * invVar * expval) / (dotNH_sqr * dotNH_sqr);</div><div class="line">}</div></div><!-- fragment --><p>The complete BRDF evalution including specular weighting and diffuse model might be coded like this: </p><div class="fragment"><div class="line">vec3 dotNLWeightedBrdf(in viewdata vdata, in vec3 v3_light)</div><div class="line">{</div><div class="line">    vec3 L = toSystem(vdata.t, vdata.b, vdata.n, v3_light);     <span class="comment">//transform light to local tangent space system</span></div><div class="line">    <span class="keywordtype">float</span> dotNL = max(0.0, L.z);    </div><div class="line">    <span class="keywordflow">return</span> = vdata.diffuse * (M_1_PI * dotNL) + vdata.specular * dotNLWeightedSpecularTerm(vdata, L, dotNL);</div><div class="line">}</div></div><!-- fragment --><p> The vdata structure contains the BRDF parameters (<em>diffuse, specular, speclobe</em>), the tangent space system (<em>tangent, bi-tangent, normal</em>) and the local view direction for the current fragment.</p>
<h2><a class="anchor" id="svbrdf_sec02_02"></a>
AxF Version 1.1</h2>
<p>AxF version 1.1 introduces a measured clearcoat model as described in Section <a class="el" href="page1.html#svbrdf_subsec03">Coated SVBRDFs</a> which (in AxF terminology) acts as a <em>filter</em> node for the SVBRDF representation which corresponds to a physical layering of the coating <em>on-top</em> of the SVBRDF. The clearcoat model assumes ideal specular Fresnel reflection and has an index of refraction parameter which defines the reflectivity and transmission properties of the clearcoat. It can also be a texture allowing materials with spatially varying clearcoat properties like e.g. a partially coated material. The second parameter is a normal map which allows to represent the well-known orange peel effect of coatings.</p>
<p>Furthermore, this version adds Fresnel weighting of the specular term in order to better model the increased specular reflection for grazing angles. The required change for the placeholder variable <em>F</em> in the above GLSL shader code is as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> V_H = clampedDot(vdata.V,normalize(H));</div><div class="line"><span class="keywordtype">float</span> F = fresnelSchlick(V_H,vdata.speclobe.F0);</div></div><!-- fragment --><h2><a class="anchor" id="svbrdf_sec02_03"></a>
AxF Version 1.3</h2>
<p>This version introduces a slight change to the clearcoat model: it allows also non-physical clearcoat without refracting the rays for the underlying layer.</p>
<h2><a class="anchor" id="svbrdf_sec02_04"></a>
AxF Version 1.4</h2>
<p>This release adds two new map types which increase realism effectively: Alpha Maps for basic transparency and Height/Displacement Maps for 3D structure.</p>
<h2><a class="anchor" id="svbrdf_sec02_05"></a>
AxF Version 1.5</h2>
<p>This release adds support for the <a class="el" href="page1.html#svbrdf_modeling_para05">GGX BRDF model</a>.</p>
<h1><a class="anchor" id="svbrdf_sec03"></a>
SVRDF Implementation Guideline</h1>
<p>We recommend to support the AXF_COMPAT_PROF_SVRDF and AXF_COMPAT_PROF_SVRDF_REFRACT profiles (cf. <a class="el" href="namespaceaxf_1_1decoding.html#ac3229499828c83f0c934e1c865a452d3" title="Check if representation fits into the given compatibility profile. ">axf::decoding::axfCheckRepresentationCompatibilityProfile()</a>). Resources, i.e. textures and parameters should be queried using the <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html" title="Decodes texture resources from AxF representations. ">axf::decoding::TextureDecoder</a> interface. The following code checks the AxF file for an appropriate representation, creates the TextureDecoder and retrieves the texture: </p><dl class="section note"><dt>Note</dt><dd>Instead of using AxF type key strings and texture names directly, it is recommended to use the corresponding preprocessor defines which can be found in <a class="el" href="_ax_f__basic__io_8h_source.html">AxF_basic_io.h</a>. <div class="fragment"><div class="line"><span class="keyword">typedef</span> std::shared_ptr&lt;TextureDecoder,TextureDecoder::Deleter&gt; PTextureDecoder;</div><div class="line"><span class="comment">//open axf file</span></div><div class="line">...</div><div class="line"><span class="comment">// select material and representation</span></div><div class="line">...</div><div class="line">AXF_REPRESENTATION_HANDLE h_axf_rep = <a class="code" href="namespaceaxf_1_1decoding.html#a3c04510b187bd2d96d58d4f762e5c3b9">axfGetRepresentation</a>( h_axf_file, s_mat, i_rep_index );</div><div class="line"><span class="keywordflow">if</span> ( !h_axf_rep ) <span class="keywordflow">throw</span>(...);</div><div class="line"></div><div class="line"><span class="keywordtype">char</span> s_buf[AXF_MAX_NAME];</div><div class="line"><a class="code" href="namespaceaxf_1_1decoding.html#a57cd171d9aa6a6c53e0ddceb8dd06898">axfGetRepresentationClass</a>(h_axf_rep, s_buf, AXF_MAX_NAME);</div><div class="line"><span class="keywordflow">if</span> ( s_buf == AXF_REPRESENTATION_CLASS_SVBRDF )</div><div class="line">{</div><div class="line">    <span class="comment">//retrieve diffuse and specular model</span></div><div class="line">    AXF_REPRESENTATION_HANDLE h_axf_rep_diffuse = <a class="code" href="namespaceaxf_1_1decoding.html#a5dbc9210d9c3801de81fb22d4cd9ed43">axfGetSvbrdfDiffuseModelRepresentation</a>( h_axf_rep );</div><div class="line">    AXF_REPRESENTATION_HANDLE h_axf_rep_specular = <a class="code" href="namespaceaxf_1_1decoding.html#a736a18d854555b7a29eb38dade7f538c">axfGetSvbrdfSpecularModelRepresentation</a>( h_axf_rep );</div><div class="line">    <span class="keywordflow">if</span> ( !h_axf_rep_specular || !h_axf_rep_diffuse ) <span class="keywordflow">throw</span>(...)</div><div class="line"></div><div class="line">    <span class="comment">//retrieve type keys</span></div><div class="line">    <a class="code" href="namespaceaxf_1_1decoding.html#a544463086d0f705d06909be912f51ce2">axfGetRepresentationTypeKey</a>( h_axf_rep_specular, s_buf, AXF_MAX_NAME );</div><div class="line">    std::string s_diffuse_model_type_key = s_buf;</div><div class="line">    <a class="code" href="namespaceaxf_1_1decoding.html#a544463086d0f705d06909be912f51ce2">axfGetRepresentationTypeKey</a>( h_axf_rep_specular, s_buf, AXF_MAX_NAME );</div><div class="line">    std::string s_specular_model_type_key = s_buf;</div><div class="line"></div><div class="line">    <span class="comment">//this example supports combination of Lambert diffuse and Ward specular model</span></div><div class="line">    <span class="keywordflow">if</span> ( s_diffuse_model_type_key == AXF_TYPEKEY_SVBRDF_DIFFUSE_LAMBERT &amp;&amp; s_specular_model_type_key == AXF_TYPEKEY_SVBRDF_SPECULAR_WARD )</div><div class="line">    {</div><div class="line">        <span class="comment">//create Texture decoder</span></div><div class="line">        PTextureDecoder pcl_tex_decoder = PTextureDecoder( TextureDecoder::create( h_axf_rep, pcl_decoder ), TextureDecoder::Deleter() );</div><div class="line">        <span class="keywordflow">if</span> ( !pcl_tex_decoder ) <span class="keywordflow">throw</span>(...)</div><div class="line">        <span class="comment">//load textures</span></div><div class="line">        ...</div><div class="line">        <span class="keywordtype">int</span> i_num_textures = pcl_tex_decoder-&gt;getNumTextures();</div><div class="line">        <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; i_num_textures; ++i )</div><div class="line">        {</div><div class="line">            <span class="comment">//retrieve texture name, size and parameters</span></div><div class="line">            pcl_tex_decoder-&gt;getTextureName(i,s_buf, AXF_MAX_NAME);</div><div class="line">            std::string s_texture_name = s_buf;</div><div class="line">            <span class="keywordtype">int</span> i_width, i_height, i_depth, i_num_channels, i_datatype;</div><div class="line">            pcl_tex_decoder-&gt;getTextureSize(i, 0, i_width, i_height, i_depth, i_num_channels, i_datatype);</div><div class="line">            <span class="keywordtype">int</span> i_min_filter, i_mag_filter, i_wrap_s, i_wrap_t, <span class="keywordtype">int</span> i_wrap_r;</div><div class="line">            <span class="keywordtype">bool</span> b_texture_array;</div><div class="line">            pcl_tex_decoder-&gt;getTextureParams(i, i_min_filter, i_mag_filter, i_wrap_s, i_wrap_t, i_wrap_r, b_texture_array);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> ( s_buf == AXF_SVBRDF_TEXTURE_NAME_DIFFUSE_COLOR )</div><div class="line">            {</div><div class="line">            <span class="comment">//load into internal data structures...</span></div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( s_buf == AXF_SVBRDF_TEXTURE_NAME_SPECULAR_COLOR )</div><div class="line">            {</div><div class="line">            }</div><div class="line">            ...</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></dd></dl>
<p>The names and semantics of the textures provided by the AxF representation depend on the diffuse and specular model type key (see above) and the system ID (<a class="el" href="namespaceaxf_1_1decoding.html#a16895524f5dc85432f79872337ca0659" title="Enum of different target systems supported by TextureDecoder. ">axf::decoding::ETargetSystem</a>). The following table lists the texture names for system ID_DEFAULT as returned by <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a57c1788ca4356f6814fab654cf07fef7" title="Returns the name, i.e. semantic of the given texture (cf. SVRDF Implementation Guideline) ...">axf::decoding::TextureDecoder::getTextureName()</a> and the corresponding channel semantics. (For instance, \((R,G,B)\) stands for a 3-channel color texture with channel order R, G, B.) All textures are parameterized by spatial UV coordinates and contain floating point data, which can be retrieved using <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a828db702ab229008a3dbbe49067506a8">axf::decoding::TextureDecoder::getTextureData()</a> with iDataType = TYPE_FLOAT or TYPE_HALF (<a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350b" title="Enum of property data types used in the metadata retrieval interface and TextureDecoder&#39;s property in...">axf::decoding::PropertyType</a>). Please note, that a texture can consist of only a single pixel with invalid size, i.e. a size &lt;= 0. In this case the texture should be interpreted as a spatially constant parameter.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Texture name  </th><th class="markdownTableHeadNone">#define (<a class="el" href="_ax_f__basic__io_8h_source.html">AxF_basic_io.h</a>)  </th><th class="markdownTableHeadNone">AxF Version  </th><th class="markdownTableHeadNone">Semantic   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">DiffuseColor  </td><td class="markdownTableBodyNone">AXF_SVBRDF_TEXTURE_NAME_DIFFUSE_COLOR  </td><td class="markdownTableBodyNone">1.0  </td><td class="markdownTableBodyNone">\((R,G,B)\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Normal  </td><td class="markdownTableBodyNone">AXF_SVBRDF_TEXTURE_NAME_NORMAL  </td><td class="markdownTableBodyNone">1.0  </td><td class="markdownTableBodyNone">\((X,Y,Z)\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">SpecularColor  </td><td class="markdownTableBodyNone">AXF_SVBRDF_TEXTURE_NAME_SPECULAR_COLOR  </td><td class="markdownTableBodyNone">1.0  </td><td class="markdownTableBodyNone">\((R,G,B)\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">SpecularLobe  </td><td class="markdownTableBodyNone">AXF_SVBRDF_TEXTURE_NAME_SPECULAR_LOBE  </td><td class="markdownTableBodyNone">1.0  </td><td class="markdownTableBodyNone">Isotropic: \((\alpha)\)<br />
Anisotropic: \((\alpha,\beta)\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">AnisoRotation  </td><td class="markdownTableBodyNone">AXF_SVBRDF_TEXTURE_NAME_ANISO_ROTATION  </td><td class="markdownTableBodyNone">1.0  </td><td class="markdownTableBodyNone">\((\gamma)\), rotation angle \( \gamma\in [-\frac{\pi}{2}, \frac{\pi}{2})\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Fresnel  </td><td class="markdownTableBodyNone">AXF_SVBRDF_TEXTURE_NAME_FRESNEL  </td><td class="markdownTableBodyNone">1.1  </td><td class="markdownTableBodyNone">\(F_0\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ClearcoatNormal  </td><td class="markdownTableBodyNone">AXF_SVBRDF_TEXTURE_NAME_CLEARCOAT_NORMAL  </td><td class="markdownTableBodyNone">1.1  </td><td class="markdownTableBodyNone">\((X,Y,Z)\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">ClearcoatIOR  </td><td class="markdownTableBodyNone">AXF_SVBRDF_TEXTURE_NAME_CLEARCOAT_IOR  </td><td class="markdownTableBodyNone">1.1  </td><td class="markdownTableBodyNone">\((n)\), index of refraction   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Alpha  </td><td class="markdownTableBodyNone">AXF_SVBRDF_TEXTURE_NAME_ALPHA  </td><td class="markdownTableBodyNone">1.4  </td><td class="markdownTableBodyNone">Opacity \( \in [0,1]\)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Height  </td><td class="markdownTableBodyNone">AXF_SVBRDF_TEXTURE_NAME_HEIGHT  </td><td class="markdownTableBodyNone">1.4  </td><td class="markdownTableBodyNone">Height in mm   </td></tr>
</table>
<p>Similarly, the method <a class="el" href="classaxf_1_1decoding_1_1_texture_decoder.html#a1577a9de4c6919c775ccc4fc94c5c727" title="Returns the name, i.e. semantic of the given property. AXF_MAX_KEY_SIZE is sufficient for iBufSize...">axf::decoding::TextureDecoder::getPropertyName()</a> returns the name of additional representation properties. Currently, the following properties are defined for ID_DEFAULT:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Property name  </th><th class="markdownTableHeadNone">#define (<a class="el" href="_ax_f__basic__io_8h_source.html">AxF_basic_io.h</a>)  </th><th class="markdownTableHeadNone">AxF Version  </th><th class="markdownTableHeadNone">Type  </th><th class="markdownTableHeadNone">Semantic   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">cc_no_refraction  </td><td class="markdownTableBodyNone">AXF_CLEARCOAT_PROPERTY_NAME_NO_REFRACTION  </td><td class="markdownTableBodyNone">1.3  </td><td class="markdownTableBodyNone"><a class="el" href="namespaceaxf_1_1decoding.html#ab7a5898420f230e93f06d02c3aa2350ba3f466f5fd483716a0eea0f93ab580962" title="32-bit signed integer ">axf::decoding::TYPE_INT</a>  </td><td class="markdownTableBodyNone">nonzero if clearcoat does <em>not</em> refract transmitted rays   </td></tr>
</table>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 18 2018 00:04:38 for AxF Decoding SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
